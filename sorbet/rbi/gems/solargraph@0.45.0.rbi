# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `solargraph` gem.
# Please instead update this file by running `bin/tapioca gem solargraph`.

module ReverseMarkdown
  class << self
    def cleaner; end
    def config; end
    def convert(input, options = T.unsafe(nil)); end
  end
end

module ReverseMarkdown::Converters
  class << self
    def default_converter(tag_name); end
    def lookup(tag_name); end
    def register(tag_name, converter); end
    def unregister(tag_name); end
  end
end

class ReverseMarkdown::Converters::Dd < ::ReverseMarkdown::Converters::Base
  def convert(node, state = T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Dl < ::ReverseMarkdown::Converters::Base
  def convert(node, state = T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Dt < ::ReverseMarkdown::Converters::Base
  def convert(node, state = T.unsafe(nil)); end
end

ReverseMarkdown::VERSION = T.let(T.unsafe(nil), String)

class RubyVM::AbstractSyntaxTree::Node
  def ==(other); end
  def to_sexp; end

  private

  def sexp(node, depth = T.unsafe(nil)); end
end

# The top-level namespace for the Solargraph code mapping, documentation,
# static analysis, and language server libraries.
module Solargraph
  class << self
    # A convenience method for Solargraph::Logging.logger.
    #
    # @return [Logger]
    def logger; end

    # A helper method that runs Bundler.with_unbundled_env or falls back to
    # Bundler.with_clean_env for earlier versions of Bundler.
    #
    # @return [void]
    def with_clean_env(&block); end
  end
end

# An aggregate provider for information about workspaces, sources, gems, and
# the Ruby core.
class Solargraph::ApiMap
  include ::Solargraph::ApiMap::SourceToYard

  # @param pins [Array<Solargraph::Pin::Base>]
  # @return [ApiMap] a new instance of ApiMap
  def initialize(pins: T.unsafe(nil)); end

  # True if the specified file was included in a bundle, i.e., it's either
  # included in a workspace or open in a library.
  #
  # @param filename [String]
  # @return [Boolean]
  def bundled?(filename); end

  # Catalog a bench.
  #
  # @param bench [Bench]
  def catalog(bench); end

  # @param cursor [Source::Cursor]
  # @raise [FileNotFoundError] if the cursor's file is not in the ApiMap
  # @return [SourceMap::Clip]
  def clip(cursor); end

  # Get a clip by filename and position.
  #
  # @param filename [String]
  # @param position [Position, Array(Integer, Integer)]
  # @return [SourceMap::Clip]
  def clip_at(filename, position); end

  # @param filename [String]
  # @param position [Position, Array(Integer, Integer)]
  # @raise [FileNotFoundError]
  # @return [Source::Cursor]
  def cursor_at(filename, position); end

  # Get YARD documentation for the specified path.
  #
  # @example
  #   api_map.document('String#split')
  # @param path [String] The path to find
  # @return [Array<YARD::CodeObjects::Base>]
  def document(path); end

  # Get an array of document symbols from a file.
  #
  # @param filename [String]
  # @return [Array<Pin::Symbol>]
  def document_symbols(filename); end

  # Get an array of class variable pins for a namespace.
  #
  # @param namespace [String] A fully qualified namespace
  # @return [Array<Solargraph::Pin::ClassVariable>]
  def get_class_variable_pins(namespace); end

  # Get an array of method pins for a complex type.
  #
  # The type's namespace and the context should be fully qualified. If the
  # context matches the namespace type or is a subclass of the type,
  # protected methods are included in the results. If protected methods are
  # included and internal is true, private methods are also included.
  #
  # @example
  #   api_map = Solargraph::ApiMap.new
  #   type = Solargraph::ComplexType.parse('String')
  #   api_map.get_complex_type_methods(type)
  # @param type [Solargraph::ComplexType] The complex type of the namespace
  # @param context [String] The context from which the type is referenced
  # @param internal [Boolean] True to include private methods
  # @return [Array<Solargraph::Pin::Base>]
  def get_complex_type_methods(type, context = T.unsafe(nil), internal = T.unsafe(nil)); end

  # Get suggestions for constants in the specified namespace. The result
  # may contain both constant and namespace pins.
  #
  # @param namespace [String] The namespace
  # @param contexts [Array<String>] The contexts
  # @return [Array<Solargraph::Pin::Base>]
  def get_constants(namespace, *contexts); end

  # @return [Array<Solargraph::Pin::GlobalVariable>]
  def get_global_variable_pins; end

  # Get an array of instance variable pins defined in specified namespace
  # and scope.
  #
  # @param namespace [String] A fully qualified namespace
  # @param scope [Symbol] :instance or :class
  # @return [Array<Solargraph::Pin::InstanceVariable>]
  def get_instance_variable_pins(namespace, scope = T.unsafe(nil)); end

  # Get a stack of method pins for a method name in a namespace. The order
  # of the pins corresponds to the ancestry chain, with highest precedence
  # first.
  #
  # @example
  #   api_map.get_method_stack('Subclass', 'method_name')
  #   #=> [ <Subclass#method_name pin>, <Superclass#method_name pin> ]
  # @param fqns [String]
  # @param name [String]
  # @param scope [Symbol] :instance or :class
  # @return [Array<Solargraph::Pin::Method>]
  def get_method_stack(fqns, name, scope: T.unsafe(nil)); end

  # Get an array of methods available in a particular context.
  #
  # @param fqns [String] The fully qualified namespace to search for methods
  # @param scope [Symbol] :class or :instance
  # @param visibility [Array<Symbol>] :public, :protected, and/or :private
  # @param deep [Boolean] True to include superclasses, mixins, etc.
  # @return [Array<Solargraph::Pin::Method>]
  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil), deep: T.unsafe(nil)); end

  # Get an array of pins that match the specified path.
  #
  # @param path [String]
  # @return [Array<Pin::Base>]
  def get_path_pins(path); end

  # Get an array of all suggestions that match the specified path.
  #
  # @deprecated Use #get_path_pins instead.
  # @param path [String] The path to find
  # @return [Array<Solargraph::Pin::Base>]
  def get_path_suggestions(path); end

  # @return [Array<Solargraph::Pin::Base>]
  def get_symbols; end

  # @return [Environ]
  def implicit; end

  # @param pins [Array<Pin::Base>]
  # @return [self]
  def index(pins); end

  # An array of pins based on Ruby keywords (`if`, `end`, etc.).
  #
  # @return [Enumerable<Solargraph::Pin::Keyword>]
  def keyword_pins; end

  # @param location [Solargraph::Location]
  # @return [Array<Solargraph::Pin::Base>]
  def locate_pins(location); end

  # Map a single source.
  #
  # @param source [Source]
  # @return [self]
  def map(source); end

  # @param name [String]
  # @return [YARD::Tags::MacroDirective, nil]
  def named_macro(name); end

  # True if the namespace exists.
  #
  # @param name [String] The namespace to match
  # @param context [String] The context to search
  # @return [Boolean]
  def namespace_exists?(name, context = T.unsafe(nil)); end

  # An array of namespace names defined in the ApiMap.
  #
  # @return [Set<String>]
  def namespaces; end

  # @return [Array<Solargraph::Pin::Base>]
  def pins; end

  # Get a fully qualified namespace name. This method will start the search
  # in the specified context until it finds a match for the name.
  #
  # @param namespace [String, nil] The namespace to match
  # @param context [String] The context to search
  # @return [String]
  def qualify(namespace, context = T.unsafe(nil)); end

  # Get an array of all symbols in the workspace that match the query.
  #
  # @param query [String]
  # @return [Array<Pin::Base>]
  def query_symbols(query); end

  def rebindable_method_names; end
  def required; end

  # Get a list of documented paths that match the query.
  #
  # @example
  #   api_map.query('str') # Results will include `String` and `Struct`
  # @param query [String] The text to match
  # @return [Array<String>]
  def search(query); end

  # Get a source map by filename.
  #
  # @param filename [String]
  # @raise [FileNotFoundError]
  # @return [SourceMap]
  def source_map(filename); end

  # @return [Array<SourceMap>]
  def source_maps; end

  # Check if a class is a superclass of another class.
  #
  # @param sup [String] The superclass
  # @param sub [String] The subclass
  # @return [Boolean]
  def super_and_sub?(sup, sub); end

  # Check if the host class includes the specified module.
  #
  # @param host [String] The class
  # @param mod [String] The module
  # @return [Boolean]
  def type_include?(host, mod); end

  # @return [Array<String>]
  def unresolved_requires; end

  # @return [YardMap]
  def yard_map; end

  private

  # @return [Solargraph::ApiMap::Cache]
  def cache; end

  # Get the namespace's type (Class or Module).
  #
  # @param fqns [String] A fully qualified namespace
  # @return [Symbol, nil] :class, :module, or nil
  def get_namespace_type(fqns); end

  # @param fqns [String]
  # @param visibility [Array<Symbol>]
  # @param skip [Set<String>]
  # @return [Array<Pin::Base>]
  def inner_get_constants(fqns, visibility, skip); end

  # @param fqns [String] A fully qualified namespace
  # @param scope [Symbol] :class or :instance
  # @param visibility [Array<Symbol>] :public, :protected, and/or :private
  # @param deep [Boolean]
  # @param skip [Set<String>]
  # @param no_core [Boolean] Skip core classes if true
  # @return [Array<Pin::Base>]
  def inner_get_methods(fqns, scope, visibility, deep, skip, no_core = T.unsafe(nil)); end

  # @param name [String]
  # @param root [String]
  # @param skip [Set<String>]
  # @return [String, nil]
  def inner_qualify(name, root, skip); end

  # @return [Hash]
  def path_macros; end

  # Sort an array of pins to put nil or undefined variables last.
  #
  # @param pins [Array<Solargraph::Pin::Base>]
  # @return [Array<Solargraph::Pin::Base>]
  def prefer_non_nil_variables(pins); end

  # @param namespace [String]
  # @param context [String]
  # @return [String]
  def qualify_lower(namespace, context); end

  def qualify_superclass(fqsub); end

  # @param pin [Pin::MethodAlias, Pin::Base]
  # @return [Pin::Method]
  def resolve_method_alias(pin); end

  # @param pins [Array<Pin::Base>]
  # @param visibility [Array<Symbol>]
  # @return [Array<Pin::Base>]
  def resolve_method_aliases(pins, visibility = T.unsafe(nil)); end

  # A hash of source maps with filename keys.
  #
  # @return [Hash{String => SourceMap}]
  def source_map_hash; end

  # @return [ApiMap::Store]
  def store; end

  class << self
    # Create an ApiMap with a workspace in the specified directory.
    #
    # @param directory [String]
    # @return [ApiMap]
    def load(directory); end
  end
end

module Solargraph::ApiMap::BundlerMethods
  private

  # @param directory [String]
  # @return [Hash]
  def require_from_bundle(directory); end

  class << self
    # @param directory [String]
    # @return [Hash]
    def require_from_bundle(directory); end
  end
end

class Solargraph::ApiMap::Cache
  # @return [Cache] a new instance of Cache
  def initialize; end

  # @return [void]
  def clear; end

  # @return [Boolean]
  def empty?; end

  # @return [Array<Pin::Base>]
  def get_constants(namespace, context); end

  # @return [Array<Pin::Method>]
  def get_methods(fqns, scope, visibility, deep); end

  # @return [String]
  def get_qualified_namespace(name, context); end

  # @return [Pin::Method]
  def get_receiver_definition(path); end

  # @return [Boolean]
  def receiver_defined?(path); end

  def set_constants(namespace, context, value); end
  def set_methods(fqns, scope, visibility, deep, value); end
  def set_qualified_namespace(name, context, value); end
  def set_receiver_definition(path, pin); end
end

module Solargraph::ApiMap::SourceToYard
  # Get the YARD CodeObject at the specified path.
  #
  # @param path [String]
  # @return [YARD::CodeObjects::Base]
  def code_object_at(path); end

  # @return [Array<String>]
  def code_object_paths; end

  # @param store [ApiMap::Store] ApiMap pin store
  # @return [void]
  def rake_yard(store); end

  private

  # @return [Hash{String => YARD::CodeObjects::Base}]
  def code_object_map; end

  # @return [YARD::CodeObjects::RootObject]
  def root_code_object; end
end

class Solargraph::ApiMap::Store
  # @param pins [Enumerable<Solargraph::Pin::Base>]
  # @return [Store] a new instance of Store
  def initialize(pins = T.unsafe(nil)); end

  # @return [Enumerable<Pin::Block>]
  def block_pins; end

  # @param fqns [String]
  # @return [Array<String>]
  def domains(fqns); end

  # @param fqns [String]
  # @return [Enumerable<Solargraph::Pin::Base>]
  def get_class_variables(fqns); end

  # @param fqns [String]
  # @param visibility [Array<Symbol>]
  # @return [Enumerable<Solargraph::Pin::Base>]
  def get_constants(fqns, visibility = T.unsafe(nil)); end

  # @param fqns [String]
  # @return [Array<String>]
  def get_extends(fqns); end

  # @param fqns [String]
  # @return [Array<String>]
  def get_includes(fqns); end

  # @param fqns [String]
  # @param scope [Symbol] :class or :instance
  # @return [Enumerable<Solargraph::Pin::Base>]
  def get_instance_variables(fqns, scope = T.unsafe(nil)); end

  # @param fqns [String]
  # @param scope [Symbol]
  # @param visibility [Array<Symbol>]
  # @return [Enumerable<Solargraph::Pin::Base>]
  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil)); end

  # @param path [String]
  # @return [Enumerable<Solargraph::Pin::Base>]
  def get_path_pins(path); end

  # @param fqns [String]
  # @return [Array<String>]
  def get_prepends(fqns); end

  # @param fqns [String]
  # @return [String, nil]
  def get_superclass(fqns); end

  # @return [Enumerable<Solargraph::Pin::Base>]
  def get_symbols; end

  def inspect; end

  # @return [Enumerable<Solargraph::Pin::Method>]
  def method_pins; end

  # @return [Hash]
  def named_macros; end

  # @param fqns [String]
  # @return [Boolean]
  def namespace_exists?(fqns); end

  # @return [Enumerable<Solargraph::Pin::Base>]
  def namespace_pins; end

  # @return [Set<String>]
  def namespaces; end

  # @return [Enumerable<Solargraph::Pin::Base>]
  def pins; end

  # @param klass [Class]
  # @return [Enumerable<Solargraph::Pin::Base>]
  def pins_by_class(klass); end

  private

  def all_instance_variables; end
  def extend_references; end

  # @param fqns [String]
  # @return [Array<Solargraph::Pin::Namespace>]
  def fqns_pins(fqns); end

  def fqns_pins_map; end
  def include_references; end

  # @return [void]
  def index; end

  # @param name [String]
  # @return [Enumerable<Solargraph::Pin::Base>]
  def namespace_children(name); end

  # @return [Hash]
  def namespace_map; end

  def path_pin_hash; end
  def prepend_references; end
  def superclass_references; end

  # @return [Enumerable<Solargraph::Pin::Symbol>]
  def symbols; end
end

# A container of source maps and workspace data to be cataloged in an ApiMap.
class Solargraph::Bench
  # @param source_maps [Array<SourceMap>, Set<SourceMap>]
  # @param workspace [Workspace]
  # @param external_requires [Array<String>, Set<String>]
  # @return [Bench] a new instance of Bench
  def initialize(source_maps: T.unsafe(nil), workspace: T.unsafe(nil), external_requires: T.unsafe(nil)); end

  # @return [Set<String>]
  def external_requires; end

  # @return [Set<SourceMap>]
  def source_maps; end

  # @return [Workspace]
  def workspace; end
end

class Solargraph::BundleNotFoundError < ::StandardError; end

# A container for type data based on YARD type tags.
class Solargraph::ComplexType
  # @param types [Array<UniqueType>]
  # @return [ComplexType] a new instance of ComplexType
  def initialize(types = T.unsafe(nil)); end

  def [](index); end

  # @return [Boolean]
  def all?(&block); end

  # @return [Array]
  # @yieldparam [UniqueType]
  def each(&block); end

  def first; end
  def length; end
  def map(&block); end
  def method_missing(name, *args, &block); end
  def namespace; end

  # @return [Boolean]
  def nullable?; end

  # @param api_map [ApiMap]
  # @param context [String]
  # @return [ComplexType]
  def qualify(api_map, context = T.unsafe(nil)); end

  def select(&block); end

  # @param dst [String]
  # @return [ComplexType]
  def self_to(dst); end

  # @return [Boolean]
  def selfy?; end

  def to_s; end

  private

  # @param dst [String]
  # @return [String]
  # @todo This is a quick and dirty hack that forces `self` keywords
  #   to reference an instance of their class and never the class itself.
  #   This behavior may change depending on which result is expected
  #   from YARD conventions. See https://github.com/lsegal/yard/issues/1257
  def reduce_class(dst); end

  # @return [Boolean]
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    # Parse type strings into a ComplexType.
    #
    # @example
    #   ComplexType.parse 'String', 'Foo', 'nil' #=> [String, Foo, nil]
    # @note The `partial` parameter is used to indicate that the method is
    #   receiving a string that will be used inside another ComplexType.
    #   It returns arrays of ComplexTypes instead of a single cohesive one.
    #   Consumers should not need to use this parameter; it should only be
    #   used internally.
    # @param *strings [Array<String>] The type definitions to parse
    # @param partial [Boolean] True if the string is part of a another type
    # @return [ComplexType, Array, nil]
    def parse(*strings, partial: T.unsafe(nil)); end

    # @param strings [Array<String>]
    # @return [ComplexType]
    def try_parse(*strings); end
  end
end

Solargraph::ComplexType::BOOLEAN = T.let(T.unsafe(nil), Solargraph::ComplexType)
Solargraph::ComplexType::NIL = T.let(T.unsafe(nil), Solargraph::ComplexType)
Solargraph::ComplexType::ROOT = T.let(T.unsafe(nil), Solargraph::ComplexType)
Solargraph::ComplexType::SELF = T.let(T.unsafe(nil), Solargraph::ComplexType)
Solargraph::ComplexType::SYMBOL = T.let(T.unsafe(nil), Solargraph::ComplexType)

# Methods for accessing type data.
module Solargraph::ComplexType::TypeMethods
  def ==(other); end

  # @return [Boolean]
  def defined?; end

  # @return [Boolean]
  def duck_type?; end

  # @return [Boolean]
  def fixed_parameters?; end

  # @return [Boolean]
  def hash_parameters?; end

  # @return [Array<ComplexType>]
  def key_types; end

  # @return [Boolean]
  def list_parameters?; end

  # @return [String]
  def name; end

  # @return [String]
  def namespace; end

  # @return [Boolean]
  def nil_type?; end

  # @return [Boolean]
  def parameters?; end

  # Generate a ComplexType that fully qualifies this type's namespaces.
  #
  # @param api_map [ApiMap] The ApiMap that performs qualification
  # @param context [String] The namespace from which to resolve names
  # @return [ComplexType] The generated ComplexType
  def qualify(api_map, context = T.unsafe(nil)); end

  # @return [Boolean]
  def rooted?; end

  # @return [Symbol] :class or :instance
  def scope; end

  # @return [String]
  def substring; end

  # @return [Array<ComplexType>]
  def subtypes; end

  # @return [String]
  def tag; end

  # @return [Boolean]
  def undefined?; end

  # @return [Array<ComplexType>]
  def value_types; end

  # @return [Boolean]
  def void?; end
end

Solargraph::ComplexType::UNDEFINED = T.let(T.unsafe(nil), Solargraph::ComplexType)

# An individual type signature. A complex type can consist of multiple
# unique types.
class Solargraph::ComplexType::UniqueType
  include ::Solargraph::ComplexType::TypeMethods

  # Create a UniqueType with the specified name and an optional substring.
  # The substring is the parameter section of a parametrized type, e.g.,
  # for the type `Array<String>`, the name is `Array` and the substring is
  # `<String>`.
  #
  # @param name [String] The name of the type
  # @param substring [String] The substring of the type
  # @return [UniqueType] a new instance of UniqueType
  def initialize(name, substring = T.unsafe(nil)); end

  def self_to(dst); end

  # @return [Boolean]
  def selfy?; end

  def to_s; end
end

Solargraph::ComplexType::UniqueType::BOOLEAN = T.let(T.unsafe(nil), Solargraph::ComplexType::UniqueType)
Solargraph::ComplexType::UniqueType::UNDEFINED = T.let(T.unsafe(nil), Solargraph::ComplexType::UniqueType)
Solargraph::ComplexType::VOID = T.let(T.unsafe(nil), Solargraph::ComplexType)
class Solargraph::ComplexTypeError < ::StandardError; end

# Conventions provide a way to modify an ApiMap based on expectations about
# one of its sources.
module Solargraph::Convention
  class << self
    # @param yard_map [YardMap]
    # @return [Environ]
    def for_global(yard_map); end

    # @param source_map [SourceMap]
    # @return [Environ]
    def for_local(source_map); end

    # @param convention [Class<Convention::Base>]
    # @return [void]
    def register(convention); end
  end
end

# The base class for Conventions.
#
# A Convention provides Environs that customize ApiMaps with additional
# pins and other information. Subclasses should implement the `local` and
# `global` methods as necessary.
class Solargraph::Convention::Base
  # The Environ for a YARD map.
  # Subclasses can override this method.
  #
  # @param yard_map [YardMap]
  # @return [Environ]
  def global(yard_map); end

  # The Environ for a source map.
  # Subclasses can override this method.
  #
  # @param source_map [SourceMap]
  # @return [Environ]
  def local(source_map); end
end

Solargraph::Convention::Base::EMPTY_ENVIRON = T.let(T.unsafe(nil), Solargraph::Environ)

class Solargraph::Convention::Gemfile < ::Solargraph::Convention::Base
  def local(source_map); end
end

class Solargraph::Convention::Gemspec < ::Solargraph::Convention::Base
  def local(source_map); end
end

class Solargraph::Convention::Rspec < ::Solargraph::Convention::Base
  def local(source_map); end

  private

  def extras; end
end

# The Diagnostics library provides reporters for analyzing problems in code
# and providing the results to language server clients.
module Solargraph::Diagnostics
  class << self
    # Add a reporter with a name to identify it in .solargraph.yml files.
    #
    # @param name [String] The name
    # @param klass [Class<Solargraph::Diagnostics::Base>] The class implementation
    # @return [void]
    def register(name, klass); end

    # Find a reporter by name.
    #
    # @param name [String] The name with which the reporter was registered
    # @return [Class<Solargraph::Diagnostics::Base>]
    def reporter(name); end

    # Get an array of reporter names.
    #
    # @return [Array<String>]
    def reporters; end

    private

    # @return [Hash]
    def reporter_hash; end
  end
end

# The base class for diagnostics reporters.
class Solargraph::Diagnostics::Base
  # @return [Base] a new instance of Base
  def initialize(*args); end

  # @return [Array<String>]
  def args; end

  # Perform a diagnosis on a Source within the context of an ApiMap.
  # The result is an array of hash objects that conform to the LSP's
  # Diagnostic specification.
  #
  # Subclasses should override this method.
  #
  # @param source [Solargraph::Source]
  # @param api_map [Solargraph::ApiMap]
  # @return [Array<Hash>]
  def diagnose(source, api_map); end
end

# RequireNotFound reports required paths that could not be resolved to
# either a file in the workspace or a gem.
class Solargraph::Diagnostics::RequireNotFound < ::Solargraph::Diagnostics::Base
  def diagnose(source, api_map); end

  private

  # @param path [String]
  # @param location [Location]
  # @return [Hash]
  def require_error(path, location); end
end

# This reporter provides linting through RuboCop.
class Solargraph::Diagnostics::Rubocop < ::Solargraph::Diagnostics::Base
  include ::Solargraph::Diagnostics::RubocopHelpers

  # @param source [Solargraph::Source]
  # @param _api_map [Solargraph::ApiMap]
  # @return [Array<Hash>]
  def diagnose(source, _api_map); end

  private

  # @param resp [Hash]
  # @return [Array<Hash>]
  def make_array(resp); end

  # @param off [Hash]
  # @return [Position]
  def offense_ending_position(off); end

  # @param off [Hash]
  # @return [Range]
  def offense_range(off); end

  # @param off [Hash]
  # @return [Position]
  def offense_start_position(off); end

  # Convert a RuboCop offense to an LSP diagnostic
  #
  # @param off [Hash] Offense received from Rubocop
  # @return [Hash] LSP diagnostic
  def offense_to_diagnostic(off); end

  # Extracts the rubocop version from _args_
  #
  # @return [String]
  def rubocop_version; end
end

# Conversion of RuboCop severity names to LSP constants
Solargraph::Diagnostics::Rubocop::SEVERITIES = T.let(T.unsafe(nil), Hash)

# Utility methods for the RuboCop diagnostics reporter.
module Solargraph::Diagnostics::RubocopHelpers
  private

  # RuboCop internally uses capitalized drive letters for Windows paths,
  # so we need to convert the paths provided to the command.
  #
  # @param path [String]
  # @return [String]
  def fix_drive_letter(path); end

  # Generate command-line options for the specified filename and code.
  #
  # @param filename [String]
  # @param code [String]
  # @return [Array(Array<String>, Array<String>)]
  def generate_options(filename, code); end

  # @return [String]
  # @todo This is a smelly way to redirect output, but the RuboCop specs do
  #   the same thing.
  def redirect_stdout; end

  # Requires a specific version of rubocop, or the latest installed version
  # if _version_ is `nil`.
  #
  # @param version [String]
  # @raise [InvalidRubocopVersionError] if _version_ is not installed
  def require_rubocop(version = T.unsafe(nil)); end

  class << self
    # RuboCop internally uses capitalized drive letters for Windows paths,
    # so we need to convert the paths provided to the command.
    #
    # @param path [String]
    # @return [String]
    def fix_drive_letter(path); end

    # Generate command-line options for the specified filename and code.
    #
    # @param filename [String]
    # @param code [String]
    # @return [Array(Array<String>, Array<String>)]
    def generate_options(filename, code); end

    # @return [String]
    # @todo This is a smelly way to redirect output, but the RuboCop specs do
    #   the same thing.
    def redirect_stdout; end

    # Requires a specific version of rubocop, or the latest installed version
    # if _version_ is `nil`.
    #
    # @param version [String]
    # @raise [InvalidRubocopVersionError] if _version_ is not installed
    def require_rubocop(version = T.unsafe(nil)); end
  end
end

# These severity constants match the DiagnosticSeverity constants in the
# language server protocol.
module Solargraph::Diagnostics::Severities; end

Solargraph::Diagnostics::Severities::ERROR = T.let(T.unsafe(nil), Integer)
Solargraph::Diagnostics::Severities::HINT = T.let(T.unsafe(nil), Integer)
Solargraph::Diagnostics::Severities::INFORMATION = T.let(T.unsafe(nil), Integer)
Solargraph::Diagnostics::Severities::WARNING = T.let(T.unsafe(nil), Integer)

# TypeCheck reports methods with undefined return types, untagged
# parameters, and invalid param tags.
class Solargraph::Diagnostics::TypeCheck < ::Solargraph::Diagnostics::Base
  def diagnose(source, api_map); end

  private

  # @param location [Location]
  # @param source [Source]
  # @return [Hash]
  def extract_first_line(location, source); end

  # @param position [Solargraph::Position]
  # @param source [Solargraph::Source]
  # @return [Integer]
  def last_character(position, source); end
end

class Solargraph::Diagnostics::UpdateErrors < ::Solargraph::Diagnostics::Base
  def diagnose(source, api_map); end

  private

  # Combine an array of ranges by their starting lines.
  #
  # @param code [String]
  # @param ranges [Array<Range>]
  # @return [Array<Range>]
  def combine_ranges(code, ranges); end
end

class Solargraph::DiagnosticsError < ::RuntimeError; end

class Solargraph::Documentor
  # @return [Documentor] a new instance of Documentor
  def initialize(directory, rebuild: T.unsafe(nil), out: T.unsafe(nil)); end

  # @return [Boolean] True if all specs were found and documented.
  def document; end

  class << self
    # @param directory [String]
    # @return [Hash]
    def specs_from_bundle(directory); end
  end
end

Solargraph::Documentor::RDOC_GEMS = T.let(T.unsafe(nil), Array)

# A placeholder for the @!domain directive. It doesn't need to do anything
# for yardocs. It's only used for Solargraph API maps.
class Solargraph::DomainDirective < ::YARD::Tags::Directive
  def call; end
end

# A collection of additional data, such as map pins and required paths, that
# can be added to an ApiMap.
#
# Conventions are used to add Environs.
class Solargraph::Environ
  # @param requires [Array<String>]
  # @param domains [Array<String>]
  # @param pins [Array<Pin::Base>]
  # @return [Environ] a new instance of Environ
  def initialize(requires: T.unsafe(nil), domains: T.unsafe(nil), pins: T.unsafe(nil)); end

  # @return [self]
  def clear; end

  # @return [Array<String>]
  def domains; end

  # @param other [Environ]
  # @return [self]
  def merge(other); end

  # @return [Array<Pin::Reference::Override>]
  def pins; end

  # @return [Array<String>]
  def requires; end
end

class Solargraph::FileNotFoundError < ::RuntimeError; end
class Solargraph::InvalidOffsetError < ::RangeError; end
class Solargraph::InvalidRubocopVersionError < ::RuntimeError; end

# The LanguageServer namespace contains the classes and modules that compose
# concrete implementations of language servers.
module Solargraph::LanguageServer; end

# The CompletionItemKind constants for the language server protocol.
module Solargraph::LanguageServer::CompletionItemKinds; end

Solargraph::LanguageServer::CompletionItemKinds::CLASS = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::COLOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::CONSTANT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::CONSTRUCTOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::ENUM = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::ENUM_MEMBER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::EVENT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::FIELD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::FILE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::FOLDER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::FUNCTION = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::INTERFACE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::KEYWORD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::METHOD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::MODULE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::OPERATOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::PROPERTY = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::REFERENCE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::SNIPPET = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::STRUCT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::TEXT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::TYPE_PARAMETER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::UNIT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::VALUE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::CompletionItemKinds::VARIABLE = T.let(T.unsafe(nil), Integer)

# The ErrorCode constants for the language server protocol.
module Solargraph::LanguageServer::ErrorCodes; end

Solargraph::LanguageServer::ErrorCodes::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::INVALID_PARAMS = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::INVALID_REQUEST = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::METHOD_NOT_FOUND = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::PARSE_ERROR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::REQUEST_CANCELLED = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::SERVER_ERROR_END = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::SERVER_ERROR_START = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::SERVER_NOT_INITIALIZED = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::ErrorCodes::UNKNOWN_ERROR_CODE = T.let(T.unsafe(nil), Integer)

# The language server protocol's data provider. Hosts are responsible for
# querying the library and processing messages. They also provide thread
# safety for multi-threaded transports.
class Solargraph::LanguageServer::Host
  include ::Solargraph::LanguageServer::UriHelpers
  include ::Solargraph::Logging
  include ::Solargraph::LanguageServer::Host::Dispatch
  include ::Observable

  # @return [Host] a new instance of Host
  def initialize; end

  # Flag a method as available for dynamic registration.
  #
  # @param method [String] The method name, e.g., 'textDocument/completion'
  # @return [void]
  def allow_registration(method); end

  # True if the specified LSP method can be dynamically registered.
  #
  # @param method [String]
  # @return [Boolean]
  def can_register?(method); end

  # Cancel the method with the specified ID.
  #
  # @param id [Integer]
  # @return [void]
  def cancel(id); end

  # True if the host received a request to cancel the method with the
  # specified ID.
  #
  # @param id [Integer]
  # @return [Boolean]
  def cancel?(id); end

  # @return [void]
  def catalog; end

  # Update a document from the parameters of a textDocument/didChange
  # method.
  #
  # @param params [Hash]
  # @return [void]
  def change(params); end

  # Delete the specified ID from the list of cancelled IDs if it exists.
  #
  # @param id [Integer]
  # @return [void]
  def clear(id); end

  def client_capabilities; end

  # Sets the attribute client_capabilities
  #
  # @param value the value to set the attribute client_capabilities to.
  def client_capabilities=(_arg0); end

  # Close the file specified by the URI.
  #
  # @param uri [String]
  # @return [void]
  def close(uri); end

  # @param uri [String]
  # @param line [Integer]
  # @param column [Integer]
  # @return [Solargraph::SourceMap::Completion]
  def completions_at(uri, line, column); end

  # Update the configuration options with the provided hash.
  #
  # @param update [Hash]
  # @return [void]
  def configure(update); end

  # Respond to a notification that a file was created in the workspace.
  # The libraries will determine whether the file should be merged; see
  # Solargraph::Library#create_from_disk.
  #
  # @param uri [String] The file uri.
  # @return [Boolean] True if a library accepted the file.
  def create(uri); end

  # @return [Hash{String => Object}]
  def default_configuration; end

  # @param uri [String]
  # @param line [Integer]
  # @param column [Integer]
  # @return [Array<Solargraph::Pin::Base>]
  def definitions_at(uri, line, column); end

  # Delete the specified file from the library.
  #
  # @param uri [String] The file uri.
  # @return [void]
  def delete(uri); end

  # @param uri [String]
  # @return [void]
  def diagnose(uri); end

  # @param query [String]
  # @return [Array]
  def document(query); end

  # @param uri [String]
  # @return [Array<Solargraph::Pin::Base>]
  def document_symbols(uri); end

  # Clear the message buffer and return the most recent data.
  #
  # @return [String] The most recent data or an empty string.
  def flush; end

  # @return [Array<String>]
  def folders; end

  # @param uri [String]
  # @return [Array<Range>]
  def folding_ranges(uri); end

  def formatter_config(uri); end

  # @return [Bool] if has pending completion request
  def has_pending_completions?; end

  # Locate multiple pins that match a completion item. The first match is
  # based on the corresponding location in a library source if available.
  # Subsequent matches are based on path.
  #
  # @param params [Hash] A hash representation of a completion item
  # @return [Array<Pin::Base>]
  def locate_pins(params); end

  # Open the specified file in the library.
  #
  # @param uri [String] The file uri.
  # @param text [String] The contents of the file.
  # @param version [Integer] A version number.
  # @return [void]
  def open(uri, text, version); end

  # True if the specified file is currently open in the library.
  #
  # @param uri [String]
  # @return [Boolean]
  def open?(uri); end

  # @param uri [String]
  # @return [void]
  def open_from_disk(uri); end

  # @return [Hash]
  def options; end

  # Get a list of IDs for server requests that are waiting for responses
  # from the client.
  #
  # @return [Array<Integer>]
  def pending_requests; end

  # Prepare a library for the specified directory.
  #
  # @param directory [String]
  # @param name [String, nil]
  # @return [void]
  def prepare(directory, name = T.unsafe(nil)); end

  # Prepare multiple folders.
  #
  # @param array [Array<Hash{String => String}>]
  # @return [void]
  def prepare_folders(array); end

  # Called by adapter, to handle the request
  #
  # @param request [Hash]
  # @return [void]
  def process(request); end

  # @param query [String]
  # @return [Array<Solargraph::Pin::Base>]
  def query_symbols(query); end

  # Queue a message to be sent to the client.
  #
  # @param message [String] The message to send.
  # @return [void]
  def queue(message); end

  # @param uri [String]
  # @return [String]
  def read_text(uri); end

  # Start processing a request from the client. After the message is
  # processed, caller is responsible for sending the response.
  #
  # @param request [Hash] The contents of the message.
  # @return [Solargraph::LanguageServer::Message::Base] The message handler.
  def receive(request); end

  # @param uri [String]
  # @param line [Integer]
  # @param column [Integer]
  # @param strip [Boolean] Strip special characters from variable names
  # @param only [Boolean] If true, search current file only
  # @return [Array<Solargraph::Range>]
  def references_from(uri, line, column, strip: T.unsafe(nil), only: T.unsafe(nil)); end

  # Register the methods as capabilities with the client.
  # This method will avoid duplicating registrations and ignore methods
  # that were not flagged for dynamic registration by the client.
  #
  # @param methods [Array<String>] The methods to register
  # @return [void]
  def register_capabilities(methods); end

  # True if the specified method has been registered.
  #
  # @param method [String] The method name, e.g., 'textDocument/completion'
  # @return [Boolean]
  def registered?(method); end

  # Remove a directory.
  #
  # @param directory [String]
  # @return [void]
  def remove(directory); end

  # @param array [Array<Hash>]
  # @return [void]
  def remove_folders(array); end

  # @param query [String]
  # @return [Array<String>]
  def search(query); end

  # Send a notification to the client.
  #
  # @param method [String] The message method
  # @param params [Hash] The method parameters
  # @return [void]
  def send_notification(method, params); end

  # Send a request to the client and execute the provided block to process
  # the response. If an ID is not provided, the host will use an auto-
  # incrementing integer.
  #
  # @param method [String] The message method
  # @param params [Hash] The method parameters
  # @param block [Proc] The block that processes the response
  # @return [void]
  # @yieldparam The [Hash] result sent by the client
  def send_request(method, params, &block); end

  # Send a notification to the client.
  #
  # @param text [String]
  # @param type [Integer] A MessageType constant
  # @return [void]
  def show_message(text, type = T.unsafe(nil)); end

  # Send a notification with optional responses.
  #
  # @param text [String]
  # @param type [Integer] A MessageType constant
  # @param actions [Array<String>] Response options for the client
  # @param block The block that processes the response
  # @return [void]
  # @yieldparam The [String] action received from the client
  def show_message_request(text, type, actions, &block); end

  # @param uri [String]
  # @param line [Integer]
  # @param column [Integer]
  # @return [Array<Solargraph::Pin::Base>]
  def signatures_at(uri, line, column); end

  # Start asynchronous process handling.
  #
  # @return [void]
  def start; end

  # @return [void]
  def stop; end

  # @return [Boolean]
  def stopped?; end

  # @return [Boolean]
  def synchronizing?; end

  # Unregister the methods with the client.
  # This method will avoid duplicating unregistrations and ignore methods
  # that were not flagged for dynamic registration by the client.
  #
  # @param methods [Array<String>] The methods to unregister
  # @return [void]
  def unregister_capabilities(methods); end

  private

  # @param library [Library]
  # @return [void]
  def async_library_map(library); end

  # @return [Cataloger]
  def cataloger; end

  # @param uri [String]
  # @param change [Hash]
  # @return [Hash]
  def check_diff(uri, change); end

  # @return [Boolean]
  def client_supports_progress?; end

  # @return [Diagnoser]
  def diagnoser; end

  def do_async_library_map(library, uuid = T.unsafe(nil)); end

  # @return [Hash]
  def dynamic_capability_options; end

  # @param params [Hash]
  # @return [Source::Updater]
  def generate_updater(params); end

  # @return [MessageWorker]
  def message_worker; end

  # @param path [String]
  # @return [String]
  def normalize_separators(path); end

  # @return [Boolean]
  def prepare_rename?; end

  # A hash of client requests by ID. The host uses this to keep track of
  # pending responses.
  #
  # @return [Hash{Integer => Hash}]
  def requests; end
end

# An asynchronous library cataloging handler.
class Solargraph::LanguageServer::Host::Cataloger
  # @return [Cataloger] a new instance of Cataloger
  def initialize(host); end

  # Start the catalog thread.
  #
  # @return [void]
  def start; end

  # Stop the catalog thread.
  #
  # @return [void]
  def stop; end

  # True if the cataloger is stopped.
  #
  # @return [Boolean]
  def stopped?; end

  # Perform cataloging.
  #
  # @return [void]
  def tick; end

  private

  # @return [Host]
  def host; end
end

# An asynchronous diagnosis reporter.
class Solargraph::LanguageServer::Host::Diagnoser
  # @param host [Host]
  # @return [Diagnoser] a new instance of Diagnoser
  def initialize(host); end

  # Schedule a file to be diagnosed.
  #
  # @param uri [String]
  # @return [void]
  def schedule(uri); end

  # Start the diagnosis thread.
  #
  # @return [self]
  def start; end

  # Stop the diagnosis thread.
  #
  # @return [void]
  def stop; end

  # True is the diagnoser is stopped.
  #
  # @return [Boolean]
  def stopped?; end

  # Perform diagnoses.
  #
  # @return [void]
  def tick; end

  private

  # @return [Host]
  def host; end

  # @return [Mutex]
  def mutex; end

  # @return [Array]
  def queue; end
end

# Methods for associating sources with libraries via URIs.
module Solargraph::LanguageServer::Host::Dispatch
  # Find an explicit library match for the given URI. An explicit match
  # means the libary's workspace includes the file.
  #
  # If a matching library is found, the source corresponding to the URI
  # gets attached to it.
  #
  # @param uri [String]
  # @raise [FileNotFoundError] if the source could not be attached.
  # @return [Library, nil]
  def explicit_library_for(uri); end

  # @return [Library]
  def generic_library; end

  # Get a generic library for the given URI and attach the corresponding
  # source.
  #
  # @param uri [String]
  # @raise [FileNotFoundError] if the source could not be attached.
  # @return [Library]
  def generic_library_for(uri); end

  # Find an implicit library match for the given URI. An implicit match
  # means the file is located inside the library's workspace directory,
  # regardless of whether the workspace is configured to include it.
  #
  # If a matching library is found, the source corresponding to the URI
  # gets attached to it.
  #
  # @param uri [String]
  # @raise [FileNotFoundError] if the source could not be attached.
  # @return [Library, nil]
  def implicit_library_for(uri); end

  # @return [Array<Library>]
  def libraries; end

  # Find the best libary match for the given URI.
  #
  # @param uri [String]
  # @return [Library]
  def library_for(uri); end

  # @return [Sources]
  def sources; end

  # The Sources observer callback that merges a source into the host's
  # libraries when it gets updated.
  #
  # @param uri [String]
  # @return [void]
  def update_libraries(uri); end
end

# A serial worker Thread to handle message.
#
# this make check pending message possible, and maybe cancelled to speedup process
class Solargraph::LanguageServer::Host::MessageWorker
  # @param host [Host]
  # @return [MessageWorker] a new instance of MessageWorker
  def initialize(host); end

  # pending handle messages
  def messages; end

  # @param message [Hash] The message should be handle. will pass back to Host#receive
  # @return [void]
  def queue(message); end

  def start; end
  def stop; end

  # @return [Boolean]
  def stopped?; end

  def tick; end
end

# A Host class for managing sources.
class Solargraph::LanguageServer::Host::Sources
  include ::Observable
  include ::Solargraph::LanguageServer::UriHelpers

  # @return [Sources] a new instance of Sources
  def initialize; end

  # @return [void]
  def add_uri(uri); end

  # @param uri [String]
  # @param updater [Source::Updater]
  # @return [void]
  def async_update(uri, updater); end

  # @return [void]
  def clear; end

  # Close the source with the given URI.
  #
  # @param uri [String]
  # @return [void]
  def close(uri); end

  # Find the source with the given URI.
  #
  # @param uri [String]
  # @raise [FileNotFoundError] if the URI does not match an open source.
  # @return [Source]
  def find(uri); end

  # True if a source with given URI is currently open.
  #
  # @param uri [String]
  # @return [Boolean]
  def include?(uri); end

  # @return [String]
  def next_uri; end

  # Open a source.
  #
  # @param uri [String]
  # @param text [String]
  # @param version [Integer]
  # @return [Source]
  def open(uri, text, version); end

  def open_from_disk(uri); end

  # @return [void]
  def start; end

  # @return [void]
  def stop; end

  # @return [Boolean]
  def stopped?; end

  # @return [void]
  def tick; end

  # Update an existing source.
  #
  # @param uri [String]
  # @param updater [Source::Updater]
  # @raise [FileNotFoundError] if the URI does not match an open source.
  # @return [Source]
  def update(uri, updater); end

  private

  # @return [Mutex]
  def mutex; end

  # @return [Hash]
  def open_source_hash; end

  # An array of source URIs that are waiting to finish synchronizing.
  #
  # @return [Array<String>]
  def queue; end
end

# The Message namespace contains classes that implement language server
# protocol methods.
module Solargraph::LanguageServer::Message
  class << self
    # Register a method name and message for handling by the language
    # server.
    #
    # @example
    #   Message.register 'initialize', Solargraph::Message::Initialize
    # @param path [String] The method name
    # @param message_class [Class<Message::Base>] The message class
    # @return [void]
    def register(path, message_class); end

    # @param path [String]
    # @return [Class<Solargraph::LanguageServer::Message::Base>]
    def select(path); end

    private

    # @return [Hash{String => Class<Message::Base>}]
    def method_map; end
  end
end

class Solargraph::LanguageServer::Message::Base
  # @param host [Solargraph::LanguageServer::Host]
  # @param request [Hash]
  # @return [Base] a new instance of Base
  def initialize(host, request); end

  # @return [Hash, nil]
  def error; end

  # @return [Solargraph::LanguageServer::Host]
  def host; end

  # @return [Integer]
  def id; end

  # @return [String]
  def method; end

  # @return [Hash]
  def params; end

  # @return [void]
  def post_initialize; end

  # @return [void]
  def process; end

  # @return [Hash]
  def request; end

  # @return [Hash, Array, nil]
  def result; end

  # @return [void]
  def send_response; end

  # @param code [Integer] See Solargraph::LanguageServer::ErrorCodes
  # @param message [String]
  # @return [void]
  def set_error(code, message); end

  # @param data [Hash, Array, nil]
  # @return [void]
  def set_result(data); end
end

class Solargraph::LanguageServer::Message::CancelRequest < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

module Solargraph::LanguageServer::Message::CompletionItem; end

# completionItem/resolve message handler
class Solargraph::LanguageServer::Message::CompletionItem::Resolve < ::Solargraph::LanguageServer::Message::Base
  def process; end

  private

  def join_docs(pins); end

  # @param text [String]
  # @return [Hash{Symbol => String}]
  def markup_content(text); end

  # @param pins [Array<Pin::Base>]
  # @return [Hash]
  def merge(pins); end
end

class Solargraph::LanguageServer::Message::ExitNotification < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

# Messages in the Extended module are custom to the Solargraph
# implementation of the language server. In the protocol, the method
# names should start with "$/" so clients that don't recognize them can
# ignore them, as per the LSP specification.
module Solargraph::LanguageServer::Message::Extended; end

# Check if a more recent version of the Solargraph gem is available.
# Notify the client when an update exists. If the `verbose` parameter
# is true, notify the client when the gem is up to date.
class Solargraph::LanguageServer::Message::Extended::CheckGemVersion < ::Solargraph::LanguageServer::Message::Base
  # @return [CheckGemVersion] a new instance of CheckGemVersion
  def initialize(host, request, current: T.unsafe(nil), available: T.unsafe(nil)); end

  def process; end

  private

  # @return [Gem::Version]
  def available; end

  # @return [Gem::Version]
  def current; end

  # @return [String, nil]
  def error; end

  # @return [Boolean]
  def fetched?; end

  class << self
    def fetcher; end
    def fetcher=(obj); end
  end
end

Solargraph::LanguageServer::Message::Extended::CheckGemVersion::GEM_ZERO = T.let(T.unsafe(nil), Gem::Version)

class Solargraph::LanguageServer::Message::Extended::Document < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

# Update YARD documentation for installed gems. If the `rebuild`
# parameter is true, rebuild existing yardocs.
class Solargraph::LanguageServer::Message::Extended::DocumentGems < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

# Update core Ruby documentation.
class Solargraph::LanguageServer::Message::Extended::DownloadCore < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

# Update YARD documentation for installed gems. If the `rebuild`
# parameter is true, rebuild existing yardocs.
class Solargraph::LanguageServer::Message::Extended::Environment < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::Extended::Search < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::Initialize < ::Solargraph::LanguageServer::Message::Base
  def process; end

  private

  # @param section [String]
  # @param capability [String]
  # @return [Boolean]
  def dynamic_registration_for?(section, capability); end

  def static_code_action; end
  def static_completion; end
  def static_definitions; end
  def static_document_formatting; end
  def static_document_symbols; end
  def static_folding_range; end
  def static_highlights; end
  def static_hover; end
  def static_on_type_formatting; end
  def static_references; end
  def static_rename; end
  def static_signature_help; end
  def static_workspace_symbols; end

  # @return [Boolean]
  def support_workspace_folders?; end
end

class Solargraph::LanguageServer::Message::Initialized < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::MethodNotFound < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::MethodNotImplemented < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

class Solargraph::LanguageServer::Message::Shutdown < ::Solargraph::LanguageServer::Message::Base
  def process; end
end

module Solargraph::LanguageServer::Message::TextDocument; end

class Solargraph::LanguageServer::Message::TextDocument::Base < ::Solargraph::LanguageServer::Message::Base
  include ::Solargraph::LanguageServer::UriHelpers

  # Returns the value of attribute filename.
  def filename; end

  def post_initialize; end
end

class Solargraph::LanguageServer::Message::TextDocument::Completion < ::Solargraph::LanguageServer::Message::TextDocument::Base
  # @param incomplete [Boolean]
  # @return [Hash]
  def empty_result(incomplete = T.unsafe(nil)); end

  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::Definition < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end

  private

  def code_location; end
  def require_location; end
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentHighlight < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol < ::Solargraph::LanguageServer::Message::Base
  include ::Solargraph::LanguageServer::UriHelpers

  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting < ::Solargraph::LanguageServer::Message::TextDocument::Base
  include ::Solargraph::Diagnostics::RubocopHelpers

  def process; end

  private

  def cli_args(file_uri, config); end
  def config_for(file_uri); end
  def cop_list(value); end

  # @param original [String]
  # @param result [String]
  # @return [void]
  def format(original, result); end

  def formatter_class(config); end
  def log_corrections(corrections); end
end

class Solargraph::LanguageServer::Message::TextDocument::Hover < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::References < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::Rename < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp < ::Solargraph::LanguageServer::Message::TextDocument::Base
  def process; end
end

module Solargraph::LanguageServer::Message::Workspace; end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration < ::Solargraph::LanguageServer::Message::Base
  def process; end

  private

  def register_from_options; end
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles < ::Solargraph::LanguageServer::Message::Base
  include ::Solargraph::LanguageServer::UriHelpers

  def process; end
end

Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles::CHANGED = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles::CREATED = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles::DELETED = T.let(T.unsafe(nil), Integer)

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders < ::Solargraph::LanguageServer::Message::Base
  def process; end

  private

  def add_folders; end
  def remove_folders; end
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol < ::Solargraph::LanguageServer::Message::Base
  include ::Solargraph::LanguageServer::UriHelpers

  def process; end
end

# The MessageType constants from the language server specification.
module Solargraph::LanguageServer::MessageTypes; end

Solargraph::LanguageServer::MessageTypes::ERROR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::MessageTypes::INFO = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::MessageTypes::LOG = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::MessageTypes::WARNING = T.let(T.unsafe(nil), Integer)

class Solargraph::LanguageServer::Request
  # @param id [Integer]
  # @param &block The block that processes the client's response
  # @return [Request] a new instance of Request
  def initialize(id, &block); end

  # @param result [Object]
  # @return [void]
  def process(result); end

  def send_response; end
end

# The SymbolKind constants for the language server protocol.
module Solargraph::LanguageServer::SymbolKinds; end

Solargraph::LanguageServer::SymbolKinds::ARRAY = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::BOOLEAN = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::CLASS = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::CONSTANT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::CONSTRUCTOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::ENUM = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::ENUM_MEMBER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::EVENT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::FIELD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::FILE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::FUNCTION = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::INTERFACE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::KEY = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::METHOD = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::MODULE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::NAMESPACE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::NULL = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::NUMBER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::OBJECT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::OPERATOR = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::PACKAGE = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::PROPERTY = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::STRING = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::STRUCT = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::TYPE_PARAMETER = T.let(T.unsafe(nil), Integer)
Solargraph::LanguageServer::SymbolKinds::VARIABLE = T.let(T.unsafe(nil), Integer)

# The Transport namespace contains concrete implementations of
# communication protocols for language servers.
module Solargraph::LanguageServer::Transport; end

# A common module for running language servers in Backport.
module Solargraph::LanguageServer::Transport::Adapter
  def closing; end
  def opening; end

  # @param data [String]
  def receiving(data); end

  def update; end

  private

  # @param request [String]
  # @return [void]
  def process(request); end

  def shutdown; end
end

class Solargraph::LanguageServer::Transport::DataReader
  # @return [DataReader] a new instance of DataReader
  def initialize; end

  # Process raw data received from the client. The data will be parsed
  # into messages based on the JSON-RPC protocol. Each message will be
  # passed to the block declared via set_message_handler. Incomplete data
  # will be buffered and subsequent data will be appended to the buffer.
  #
  # @param data [String]
  def receive(data); end

  # Declare a block to be executed for each message received from the
  # client.
  #
  # @yieldparam The [Hash] message received from the client
  def set_message_handler(&block); end

  private

  # @return [void]
  def parse_message_from_buffer; end

  # @return [void]
  def prepare_to_parse_message; end
end

# Methods to handle conversions between file URIs and paths.
module Solargraph::LanguageServer::UriHelpers
  private

  # Decode text from a URI path component in LSP.
  #
  # @param text [String]
  # @return [String]
  def decode(text); end

  # Encode text to be used as a URI path component in LSP.
  #
  # @param text [String]
  # @return [String]
  def encode(text); end

  # Convert a file path to a URI.
  #
  # @param file [String]
  # @return [String]
  def file_to_uri(file); end

  # Convert a file URI to a path.
  #
  # @param uri [String]
  # @return [String]
  def uri_to_file(uri); end

  class << self
    # Decode text from a URI path component in LSP.
    #
    # @param text [String]
    # @return [String]
    def decode(text); end

    # Encode text to be used as a URI path component in LSP.
    #
    # @param text [String]
    # @return [String]
    def encode(text); end

    # Convert a file path to a URI.
    #
    # @param file [String]
    # @return [String]
    def file_to_uri(file); end

    # Convert a file URI to a path.
    #
    # @param uri [String]
    # @return [String]
    def uri_to_file(uri); end
  end
end

# A Library handles coordination between a Workspace and an ApiMap.
class Solargraph::Library
  include ::Solargraph::Logging

  # @param workspace [Solargraph::Workspace]
  # @param name [String, nil]
  # @return [Library] a new instance of Library
  def initialize(workspace = T.unsafe(nil), name = T.unsafe(nil)); end

  # Attach a source to the library.
  #
  # The attached source does not need to be a part of the workspace. The
  # library will include it in the ApiMap while it's attached. Only one
  # source can be attached to the library at a time.
  #
  # @param source [Source, nil]
  # @return [void]
  def attach(source); end

  # True if the specified file is currently attached.
  #
  # @param filename [String]
  # @return [Boolean]
  def attached?(filename); end

  def bench; end

  # Update the ApiMap from the library's workspace and open files.
  #
  # @return [void]
  def catalog; end

  # Close a file in the library. Closing a file will make it unavailable for
  # checkout although it may still exist in the workspace.
  #
  # @param filename [String]
  # @return [void]
  def close(filename); end

  # Get completion suggestions at the specified file and location.
  #
  # @param filename [String] The file to analyze
  # @param line [Integer] The zero-based line number
  # @param column [Integer] The zero-based column number
  # @return [SourceMap::Completion]
  # @todo Take a Location instead of filename/line/column
  def completions_at(filename, line, column); end

  # True if the specified file is included in the workspace (but not
  # necessarily open).
  #
  # @param filename [String]
  # @return [Boolean]
  def contain?(filename); end

  # Create a source to be added to the workspace. The file is ignored if it is
  # neither open in the library nor included in the workspace.
  #
  # @param filename [String]
  # @param text [String] The contents of the file
  # @return [Boolean] True if the file was added to the workspace.
  def create(filename, text); end

  # Create a file source from a file on disk. The file is ignored if it is
  # neither open in the library nor included in the workspace.
  #
  # @param filename [String]
  # @return [Boolean] True if the file was added to the workspace.
  def create_from_disk(filename); end

  # @return [Source, nil]
  def current; end

  # Get definition suggestions for the expression at the specified file and
  # location.
  #
  # @param filename [String] The file to analyze
  # @param line [Integer] The zero-based line number
  # @param column [Integer] The zero-based column number
  # @return [Array<Solargraph::Pin::Base>]
  # @todo Take filename/position instead of filename/line/column
  def definitions_at(filename, line, column); end

  # Delete a file from the library. Deleting a file will make it unavailable
  # for checkout and optionally remove it from the workspace unless the
  # workspace configuration determines that it should still exist.
  #
  # @param filename [String]
  # @return [Boolean] True if the file was deleted
  def delete(filename); end

  # Detach the specified file if it is currently attached to the library.
  #
  # @param filename [String]
  # @return [Boolean] True if the specified file was detached
  def detach(filename); end

  # Get diagnostics about a file.
  #
  # @param filename [String]
  # @return [Array<Hash>]
  def diagnose(filename); end

  # @param query [String]
  # @return [Array<YARD::CodeObjects::Base>]
  def document(query); end

  # Get an array of document symbols.
  #
  # Document symbols are composed of namespace, method, and constant pins.
  # The results of this query are appropriate for building the response to a
  # textDocument/documentSymbol message in the language server protocol.
  #
  # @param filename [String]
  # @return [Array<Solargraph::Pin::Base>]
  def document_symbols(filename); end

  def external_requires; end

  # Get an array of foldable ranges for the specified file.
  #
  # @deprecated The library should not need to handle folding ranges. The
  #   source itself has all the information it needs.
  # @param filename [String]
  # @return [Array<Range>]
  def folding_ranges(filename); end

  # Get an array of pins that match a path.
  #
  # @param path [String]
  # @return [Array<Solargraph::Pin::Base>]
  def get_path_pins(path); end

  def inspect; end

  # Get the pins at the specified location or nil if the pin does not exist.
  #
  # @param location [Location]
  # @return [Array<Solargraph::Pin::Base>]
  def locate_pins(location); end

  def locate_ref(location); end
  def map!; end

  # @return [Boolean]
  def mapped?; end

  # Try to merge a source into the library's workspace. If the workspace is
  # not configured to include the source, it gets ignored.
  #
  # @param source [Source]
  # @return [Boolean] True if the source was merged into the workspace.
  def merge(source); end

  # @return [String, nil]
  def name; end

  def next_map; end

  # True if the specified file is currently attached.
  #
  # @param filename [String]
  # @return [Boolean]
  def open?(filename); end

  # @param path [String]
  # @return [Array<Solargraph::Pin::Base>]
  def path_pins(path); end

  def pins; end

  # Get an array of all symbols in the workspace that match the query.
  #
  # @param query [String]
  # @return [Array<Pin::Base>]
  def query_symbols(query); end

  # Get the current text of a file in the library.
  #
  # @param filename [String]
  # @return [String]
  def read_text(filename); end

  # @param filename [String]
  # @param line [Integer]
  # @param column [Integer]
  # @param strip [Boolean] Strip special characters from variable names
  # @param only [Boolean] Search for references in the current file only
  # @return [Array<Solargraph::Range>]
  # @todo Take a Location instead of filename/line/column
  def references_from(filename, line, column, strip: T.unsafe(nil), only: T.unsafe(nil)); end

  # @param query [String]
  # @return [Array<String>]
  def search(query); end

  # Get signature suggestions for the method at the specified file and
  # location.
  #
  # @param filename [String] The file to analyze
  # @param line [Integer] The zero-based line number
  # @param column [Integer] The zero-based column number
  # @return [Array<Solargraph::Pin::Base>]
  # @todo Take filename/position instead of filename/line/column
  def signatures_at(filename, line, column); end

  def source_map_hash; end
  def source_maps; end

  # True if the ApiMap is up to date with the library's workspace and open
  # files.
  #
  # @return [Boolean]
  def synchronized?; end

  # @return [Solargraph::Workspace]
  def workspace; end

  private

  # @return [ApiMap]
  def api_map; end

  def catalog_inlock; end

  # @param source_map [SourceMap]
  def find_external_requires(source_map); end

  def handle_file_not_found(filename, error); end
  def maybe_map(source); end

  # @return [Mutex]
  def mutex; end

  # Get the source for an open file or create a new source if the file
  # exists on disk. Sources created from disk are not added to the open
  # workspace files, i.e., the version on disk remains the authoritative
  # version.
  #
  # @param filename [String]
  # @raise [FileNotFoundError] if the file does not exist
  # @return [Solargraph::Source]
  def read(filename); end

  def source_map_external_require_hash; end

  class << self
    # Create a library from a directory.
    #
    # @param directory [String] The path to be used for the workspace
    # @param name [String, nil]
    # @return [Solargraph::Library]
    def load(directory = T.unsafe(nil), name = T.unsafe(nil)); end
  end
end

# A section of text identified by its filename and range.
class Solargraph::Location
  # @param filename [String]
  # @param range [Solargraph::Range]
  # @return [Location] a new instance of Location
  def initialize(filename, range); end

  def ==(other); end

  # @return [String]
  def filename; end

  def inspect; end

  # @return [Solargraph::Range]
  def range; end

  # @return [Hash]
  def to_hash; end
end

module Solargraph::Logging
  private

  # @return [Logger]
  def logger; end

  class << self
    # @return [Logger]
    def logger; end
  end
end

Solargraph::Logging::DEFAULT_LOG_LEVEL = T.let(T.unsafe(nil), Integer)
Solargraph::Logging::LOG_LEVELS = T.let(T.unsafe(nil), Hash)

class Solargraph::Page
  # @param directory [String]
  # @return [Page] a new instance of Page
  def initialize(directory = T.unsafe(nil)); end

  # @param template [String]
  # @param layout [Boolean]
  # @param locals [Hash]
  # @return [String]
  def render(template, layout: T.unsafe(nil), locals: T.unsafe(nil)); end

  class << self
    # @param directories [Array<String>]
    # @param name [String]
    # @raise [FileNotFoundError]
    # @return [String]
    def select_template(directories, name); end
  end
end

class Solargraph::Page::Binder < ::OpenStruct
  # @param locals [Hash]
  # @param render_method [Proc]
  # @return [Binder] a new instance of Binder
  def initialize(locals, render_method); end

  # @param text [String]
  # @return [String]
  def escape(text); end

  # @param text [String]
  # @return [String]
  def htmlify(text); end

  # @param code [String]
  # @return [String]
  def ruby_to_html(code); end
end

module Solargraph::Parser
  extend ::Solargraph::Parser::Rubyvm::ClassMethods

  class << self
    # True if the parser can use RubyVM.
    #
    # @return [Boolean]
    def rubyvm?; end
  end
end

class Solargraph::Parser::CommentRipper < ::Ripper::SexpBuilderPP
  # @return [CommentRipper] a new instance of CommentRipper
  def initialize(src, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end

  def on_comment(*args); end
  def on_embdoc(*args); end
  def on_embdoc_beg(*args); end
  def on_embdoc_end(*args); end
  def parse; end
end

module Solargraph::Parser::Legacy; end

module Solargraph::Parser::Legacy::ClassMethods
  def chain(*args); end
  def chain_string(*args); end
  def infer_literal_node_type(node); end

  # @param name [String]
  # @param top [AST::Node]
  # @return [Array<AST::Node>]
  def inner_node_references(name, top); end

  # @return [Boolean]
  def is_ast_node?(node); end

  def map(source); end
  def node_range(node); end

  # @param code [String]
  # @param filename [String, nil]
  # @param line [Integer]
  # @return [Parser::AST::Node]
  def parse(code, filename = T.unsafe(nil), line = T.unsafe(nil)); end

  # @param code [String]
  # @param filename [String]
  # @return [Array(Parser::AST::Node, Array<Parser::Source::Comment>)]
  def parse_with_comments(code, filename = T.unsafe(nil)); end

  # @return [Parser::Base]
  def parser; end

  def process_node(*args); end
  def references(source, name); end
  def returns_from(node); end
  def string_ranges(node); end
  def version; end
end

# A custom builder for source parsers that ignores character encoding
# issues in literal strings.
class Solargraph::Parser::Legacy::FlawedBuilder < ::Parser::Builders::Default
  def string_value(token); end
end

# A factory for generating chains from nodes.
class Solargraph::Parser::Legacy::NodeChainer
  include ::Solargraph::Parser::Legacy::NodeMethods

  # @param node [Parser::AST::Node]
  # @param filename [String]
  # @return [NodeChainer] a new instance of NodeChainer
  def initialize(node, filename = T.unsafe(nil), in_block = T.unsafe(nil)); end

  # @return [Source::Chain]
  def chain; end

  private

  # @return [Boolean]
  def block_passed?(node); end

  # @param n [Parser::AST::Node]
  # @return [Array<Chain::Link>]
  def generate_links(n); end

  # @return [Boolean]
  def hash_is_splatted?(node); end

  class << self
    # @param node [Parser::AST::Node]
    # @param filename [String]
    # @return [Source::Chain]
    def chain(node, filename = T.unsafe(nil), in_block = T.unsafe(nil)); end

    # @param code [String]
    # @return [Source::Chain]
    def load_string(code); end
  end
end

Solargraph::Parser::Legacy::NodeChainer::Chain = Solargraph::Source::Chain

module Solargraph::Parser::Legacy::NodeMethods
  private

  def any_splatted_call?(nodes); end

  # @todo Temporarily here for testing. Move to Solargraph::Parser.
  def call_nodes_from(node); end

  def const_nodes_from(node); end
  def convert_hash(node); end
  def drill_signature(node, signature); end

  # @param cursor [Solargraph::Source::Cursor]
  def find_recipient_node(cursor); end

  # @param node [Parser::AST::Node]
  # @return [Position]
  def get_node_end_position(node); end

  # @param node [Parser::AST::Node]
  # @return [Position]
  def get_node_start_position(node); end

  # @param node [Parser::AST::Node]
  # @return [String, nil]
  def infer_literal_node_type(node); end

  # @param node [Parser::AST::Node]
  # @return [Array<String>]
  def pack_name(node); end

  def repaired_find_recipient_node(cursor); end

  # Find all the nodes within the provided node that potentially return a
  # value.
  #
  # The node parameter typically represents a method's logic, e.g., the
  # second child (after the :args node) of a :def node. A simple one-line
  # method would typically return itself, while a node with conditions
  # would return the resulting node from each conditional branch. Nodes
  # that follow a :return node are assumed to be unreachable. Nil values
  # are converted to nil node types.
  #
  # @param node [Parser::AST::Node]
  # @return [Array<Parser::AST::Node>]
  def returns_from(node); end

  def splatted_call?(node); end
  def splatted_hash?(node); end

  # @param node [Parser::AST::Node]
  # @return [String]
  def unpack_name(node); end

  class << self
    # @return [Boolean]
    def any_splatted_call?(nodes); end

    # @todo Temporarily here for testing. Move to Solargraph::Parser.
    def call_nodes_from(node); end

    def const_nodes_from(node); end
    def convert_hash(node); end
    def drill_signature(node, signature); end

    # @param cursor [Solargraph::Source::Cursor]
    def find_recipient_node(cursor); end

    # @param node [Parser::AST::Node]
    # @return [Position]
    def get_node_end_position(node); end

    # @param node [Parser::AST::Node]
    # @return [Position]
    def get_node_start_position(node); end

    # @param node [Parser::AST::Node]
    # @return [String, nil]
    def infer_literal_node_type(node); end

    # @param node [Parser::AST::Node]
    # @return [Array<String>]
    def pack_name(node); end

    def repaired_find_recipient_node(cursor); end

    # Find all the nodes within the provided node that potentially return a
    # value.
    #
    # The node parameter typically represents a method's logic, e.g., the
    # second child (after the :args node) of a :def node. A simple one-line
    # method would typically return itself, while a node with conditions
    # would return the resulting node from each conditional branch. Nodes
    # that follow a :return node are assumed to be unreachable. Nil values
    # are converted to nil node types.
    #
    # @param node [Parser::AST::Node]
    # @return [Array<Parser::AST::Node>]
    def returns_from(node); end

    # @return [Boolean]
    def splatted_call?(node); end

    # @return [Boolean]
    def splatted_hash?(node); end

    # @param node [Parser::AST::Node]
    # @return [String]
    def unpack_name(node); end
  end
end

module Solargraph::Parser::Legacy::NodeMethods::DeepInference
  class << self
    # @param node [Parser::AST::Node]
    # @return [Array<Parser::AST::Node>]
    def get_return_nodes(node); end

    private

    def get_return_nodes_from_children(parent); end
    def get_return_nodes_only(parent); end
    def reduce_to_value_nodes(nodes); end
  end
end

Solargraph::Parser::Legacy::NodeMethods::NIL_NODE = T.let(T.unsafe(nil), Parser::AST::Node)
module Solargraph::Parser::Legacy::NodeProcessors; end

class Solargraph::Parser::Legacy::NodeProcessors::AliasNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::ArgsNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end

  private

  def get_decl(node); end
end

class Solargraph::Parser::Legacy::NodeProcessors::BeginNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::BlockNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end

  private

  # @return [Boolean]
  def other_class_eval?; end
end

class Solargraph::Parser::Legacy::NodeProcessors::CasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::CvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::DefNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::DefsNode < ::Solargraph::Parser::Legacy::NodeProcessors::DefNode
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::GvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::IvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::LvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::NamespaceNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::OrasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::ResbodyNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::SclassNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Legacy::NodeProcessors::SendNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Legacy::NodeMethods

  def process; end

  private

  # @return [void]
  def process_alias_method; end

  # @return [void]
  def process_attribute; end

  # @return [void]
  def process_autoload; end

  # @return [void]
  def process_extend; end

  # @return [void]
  def process_include; end

  # @return [void]
  def process_module_function; end

  def process_prepend; end

  # @return [Boolean]
  def process_private_class_method; end

  # @return [void]
  def process_private_constant; end

  # @return [void]
  def process_require; end

  # @return [void]
  def process_visibility; end
end

class Solargraph::Parser::Legacy::NodeProcessors::SymNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

Solargraph::Parser::NodeMethods = Solargraph::Parser::Rubyvm::NodeMethods

# The processor classes used by SourceMap::Mapper to generate pins from
# parser nodes.
module Solargraph::Parser::NodeProcessor
  class << self
    # @param node [Parser::AST::Node]
    # @param region [Region]
    # @param pins [Array<Pin::Base>]
    # @return [Array(Array<Pin::Base>, Array<Pin::Base>)]
    def process(node, region = T.unsafe(nil), pins = T.unsafe(nil), locals = T.unsafe(nil)); end

    # Register a processor for a node type.
    #
    # @param type [Symbol]
    # @param cls [Class<NodeProcessor::Base>]
    # @return [Class<NodeProcessor::Base>]
    def register(type, cls); end
  end
end

class Solargraph::Parser::NodeProcessor::Base
  # @param node [Parser::AST::Node]
  # @param region [Region]
  # @param pins [Array<Pin::Base>]
  # @return [Base] a new instance of Base
  def initialize(node, region, pins, locals); end

  # @return [Array<Pin::Base>]
  def locals; end

  # @return [Parser::AST::Node]
  def node; end

  # @return [Array<Pin::Base>]
  def pins; end

  # Subclasses should override this method to generate new pins.
  #
  # @return [void]
  def process; end

  # @return [Region]
  def region; end

  private

  # @todo Candidate for deprecation
  def block_pin(position); end

  # @todo Candidate for deprecation
  def closure_pin(position); end

  def comments_for(node); end

  # @param node [Parser::AST::Node]
  # @return [Solargraph::Location]
  def get_node_location(node); end

  def named_path_pin(position); end

  # @param subregion [Region]
  # @return [void]
  def process_children(subregion = T.unsafe(nil)); end
end

# Data used by the parser to track context at various locations in a
# source.
class Solargraph::Parser::Region
  # @param source [Source]
  # @param namespace [String]
  # @param scope [Symbol]
  # @param visibility [Symbol]
  # @return [Region] a new instance of Region
  def initialize(source: T.unsafe(nil), closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil), lvars: T.unsafe(nil)); end

  # @return [Pin::Closure]
  def closure; end

  # @param node [Parser::AST::Node]
  # @return [String]
  def code_for(node); end

  # @return [String]
  def filename; end

  # @return [Array<Symbol>]
  def lvars; end

  # @return [Symbol]
  def scope; end

  # @return [Solargraph::Source]
  def source; end

  # Generate a new Region with the provided attribute changes.
  #
  # @param closure [Pin::Closure, nil]
  # @param scope [Symbol, nil]
  # @param visibility [Symbol, nil]
  # @return [Region]
  def update(closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil), lvars: T.unsafe(nil)); end

  # @return [Symbol]
  def visibility; end
end

module Solargraph::Parser::Rubyvm; end

module Solargraph::Parser::Rubyvm::ClassMethods
  def chain(*args); end
  def chain_string(*args); end
  def infer_literal_node_type(node); end

  # @param name [String]
  # @param top [AST::Node]
  # @return [Array<AST::Node>]
  def inner_node_references(name, top); end

  # @return [Boolean]
  def is_ast_node?(node); end

  def map(source); end
  def match_rubyvm_node_to_ref(top, name); end
  def node_range(node); end

  # @param code [String]
  # @param filename [String, nil]
  # @param line [Integer]
  # @return [Parser::AST::Node]
  def parse(code, filename = T.unsafe(nil), line = T.unsafe(nil)); end

  # @param code [String]
  # @param filename [String]
  # @return [Array(Parser::AST::Node, Array<Parser::Source::Comment>)]
  def parse_with_comments(code, filename = T.unsafe(nil)); end

  def process_node(*args); end
  def recipient_node(tree); end
  def references(source, name); end
  def string_ranges(node); end
  def version; end
end

# A factory for generating chains from nodes.
class Solargraph::Parser::Rubyvm::NodeChainer
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  # @param node [Parser::AST::Node]
  # @param filename [String]
  # @return [NodeChainer] a new instance of NodeChainer
  def initialize(node, filename = T.unsafe(nil), in_block = T.unsafe(nil)); end

  # @return [Source::Chain]
  def chain; end

  private

  # @return [Boolean]
  def block_passed?(node); end

  # @param n [Parser::AST::Node]
  # @return [Array<Chain::Link>]
  def generate_links(n); end

  # @return [Boolean]
  def hash_is_splatted?(node); end

  def node_to_argchains(node); end

  class << self
    # @param node [Parser::AST::Node]
    # @param filename [String]
    # @return [Source::Chain]
    def chain(node, filename = T.unsafe(nil), in_block = T.unsafe(nil)); end

    # @param code [String]
    # @return [Source::Chain]
    def load_string(code); end
  end
end

Solargraph::Parser::Rubyvm::NodeChainer::Chain = Solargraph::Source::Chain

module Solargraph::Parser::Rubyvm::NodeMethods
  private

  def any_splatted_call?(nodes); end
  def call_nodes_from(node); end
  def const_nodes_from(node); end
  def convert_hash(node); end

  # @param cursor [Solargraph::Source::Cursor]
  def find_recipient_node(cursor); end

  # @param node [RubyVM::AbstractSyntaxTree::Node]
  # @return [String, nil]
  def infer_literal_node_type(node); end

  def node?(node); end

  # @param node [RubyVM::AbstractSyntaxTree::Node]
  # @return [Array<String>]
  def pack_name(node); end

  def returns_from(node); end
  def splatted_call?(node); end
  def splatted_hash?(node); end
  def splatted_node?(node); end

  # @param node [RubyVM::AbstractSyntaxTree::Node]
  # @return [String]
  def unpack_name(node); end

  class << self
    # @return [Boolean]
    def any_splatted_call?(nodes); end

    def call_nodes_from(node); end
    def const_nodes_from(node); end
    def convert_hash(node); end

    # @param cursor [Solargraph::Source::Cursor]
    def find_recipient_node(cursor); end

    # @param node [RubyVM::AbstractSyntaxTree::Node]
    # @return [String, nil]
    def infer_literal_node_type(node); end

    # @return [Boolean]
    def node?(node); end

    # @param node [RubyVM::AbstractSyntaxTree::Node]
    # @return [Array<String>]
    def pack_name(node); end

    def returns_from(node); end

    # @return [Boolean]
    def splatted_call?(node); end

    # @return [Boolean]
    def splatted_hash?(node); end

    # @return [Boolean]
    def splatted_node?(node); end

    # @param node [RubyVM::AbstractSyntaxTree::Node]
    # @return [String]
    def unpack_name(node); end

    protected

    # @param cursor [Source::Cursor]
    # @return [Source::Cursor]
    def maybe_adjust_cursor(cursor); end

    # @param cursor [Source::Cursor]
    # @return [RubyVM::AbstractSyntaxTree::Node, nil]
    def synchronized_find_recipient_node(cursor); end

    def unsynchronized_find_recipient_node(cursor); end
  end
end

module Solargraph::Parser::Rubyvm::NodeMethods::DeepInference
  class << self
    # @param node [Parser::AST::Node]
    # @return [Array<Parser::AST::Node>]
    def get_return_nodes(node); end

    private

    def get_return_nodes_from_children(parent); end
    def get_return_nodes_only(parent); end
    def reduce_to_value_nodes(nodes); end
  end
end

module Solargraph::Parser::Rubyvm::NodeProcessors; end

class Solargraph::Parser::Rubyvm::NodeProcessors::AliasNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ArgsNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end

  private

  def extract_name(var); end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BeginNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BlockNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end

  private

  # @return [Boolean]
  def other_class_eval?; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefsNode < ::Solargraph::Parser::Rubyvm::NodeProcessors::DefNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::GvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::IvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::KwArgNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end

  private

  # @return [Boolean]
  def require_keyword?(node); end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LitNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LvasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::NamespaceNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OptArgNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OrasgnNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ResbodyNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end

  private

  # @return [Boolean]
  def exception_variable?; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SclassNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ScopeNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SendNode < ::Solargraph::Parser::NodeProcessor::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  def process; end

  private

  # @return [void]
  def process_alias_method; end

  # @return [void]
  def process_attribute; end

  # @return [void]
  def process_autoload; end

  # @return [void]
  def process_extend; end

  # @return [void]
  def process_include; end

  # @return [void]
  def process_module_function; end

  # @return [void]
  def process_prepend; end

  # @return [void]
  def process_private_class_method; end

  # @return [void]
  def process_private_constant; end

  # @return [void]
  def process_require; end

  # @return [void]
  def process_visibility; end
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SymNode < ::Solargraph::Parser::NodeProcessor::Base
  def process; end
end

class Solargraph::Parser::Snippet
  # @return [Snippet] a new instance of Snippet
  def initialize(range, text); end

  # Returns the value of attribute range.
  def range; end

  # Returns the value of attribute text.
  def text; end
end

class Solargraph::Parser::SyntaxError < ::StandardError; end

# The namespace for pins used in maps.
module Solargraph::Pin; end

# The base class for map pins.
class Solargraph::Pin::Base
  include ::Solargraph::Pin::Common
  include ::Solargraph::Pin::Conversions
  include ::Solargraph::Pin::Documenting

  # @param location [Solargraph::Location]
  # @param kind [Integer]
  # @param closure [Solargraph::Pin::Closure]
  # @param name [String]
  # @param comments [String]
  # @return [Base] a new instance of Base
  def initialize(location: T.unsafe(nil), closure: T.unsafe(nil), name: T.unsafe(nil), comments: T.unsafe(nil)); end

  # Pin equality is determined using the #nearly? method and also
  # requiring both pins to have the same location.
  def ==(other); end

  # @return [YARD::CodeObjects::Base]
  def code_object; end

  # @return [String]
  def comments; end

  # @return [Integer]
  def completion_item_kind; end

  # @return [Boolean]
  def deprecated?; end

  # @return [Array<YARD::Tags::Directive>]
  def directives; end

  # @return [YARD::Docstring]
  def docstring; end

  # @return [String, nil]
  def filename; end

  def identity; end

  # @deprecated Use #typify and/or #probe instead
  # @param api_map [ApiMap]
  # @return [ComplexType]
  def infer(api_map); end

  def inspect; end

  # @return [Solargraph::Location]
  def location; end

  # @return [Array<YARD::Tags::MacroDirective>]
  def macros; end

  # Perform a quick check to see if this pin possibly includes YARD
  # directives. This method does not require parsing the comments.
  #
  # After the comments have been parsed, this method will return false if
  # no directives were found, regardless of whether it previously appeared
  # possible.
  #
  # @return [Boolean]
  def maybe_directives?; end

  # @return [String]
  def name; end

  # True if the specified pin is a near match to this one. A near match
  # indicates that the pins contain mostly the same data. Any differences
  # between them should not have an impact on the API surface.
  #
  # @param other [Solargraph::Pin::Base, Object]
  # @return [Boolean]
  def nearly?(other); end

  # @return [String]
  def path; end

  # Infer the pin's return type via static code analysis.
  #
  # @param api_map [ApiMap]
  # @return [ComplexType]
  def probe(api_map); end

  # @return [Boolean]
  def probed?; end

  # @return [Boolean]
  def proxied?; end

  # Return a proxy for this pin with the specified return type. Other than
  # the return type and the #proxied? setting, the proxy should be a clone
  # of the original.
  #
  # @param return_type [ComplexType]
  # @return [self]
  def proxy(return_type); end

  # @param api_map [ApiMap]
  # @return [self]
  def realize(api_map); end

  # The pin's return type.
  #
  # @return [ComplexType]
  def return_type; end

  # @return [Integer, nil]
  def symbol_kind; end

  def to_s; end

  # Try to merge data from another pin. Merges are only possible if the
  # pins are near matches (see the #nearly? method). The changes should
  # not have any side effects on the API surface.
  #
  # @param pin [Pin::Base] The pin to merge into this one
  # @return [Boolean] True if the pins were merged
  def try_merge!(pin); end

  # Get a fully qualified type from the pin's return type.
  #
  # The relative type is determined from YARD documentation (@return,
  # @param, @type, etc.) and its namespaces are fully qualified using the
  # provided ApiMap.
  #
  # @param api_map [ApiMap]
  # @return [ComplexType]
  def typify(api_map); end

  # @return [Boolean]
  def variable?; end

  protected

  # @return [Boolean]
  def probed=(_arg0); end

  # @return [Boolean]
  def proxied=(_arg0); end

  # @return [ComplexType]
  def return_type=(_arg0); end

  private

  # @return [Array<YARD::Tags::Handlers::Directive>]
  def collect_macros; end

  # @param dir1 [Array<YARD::Tags::Directive>]
  # @param dir2 [Array<YARD::Tags::Directive>]
  # @return [Boolean]
  def compare_directives(dir1, dir2); end

  # True if two docstrings have the same tags, regardless of any other
  # differences.
  #
  # @param d1 [YARD::Docstring]
  # @param d2 [YARD::Docstring]
  # @return [Boolean]
  def compare_docstring_tags(d1, d2); end

  # @param tag1 [YARD::Tags::Tag]
  # @param tag2 [YARD::Tags::Tag]
  # @return [Boolean]
  def compare_tags(tag1, tag2); end

  # @return [void]
  def parse_comments; end
end

class Solargraph::Pin::BaseVariable < ::Solargraph::Pin::Base
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  # @param assignment [Parser::AST::Node, nil]
  # @return [BaseVariable] a new instance of BaseVariable
  def initialize(assignment: T.unsafe(nil), **splat); end

  def ==(other); end

  # @return [Parser::AST::Node, nil]
  def assignment; end

  def completion_item_kind; end

  # @return [Boolean]
  def nil_assignment?; end

  def probe(api_map); end
  def return_type; end

  # @return [Integer]
  def symbol_kind; end

  def try_merge!(pin); end

  # @return [Boolean]
  def variable?; end

  private

  # @return [ComplexType]
  def generate_complex_type; end
end

class Solargraph::Pin::Block < ::Solargraph::Pin::Closure
  # @return [Block] a new instance of Block
  def initialize(receiver: T.unsafe(nil), args: T.unsafe(nil), context: T.unsafe(nil), **splat); end

  def binder; end

  # @return [Array<String>]
  def parameter_names; end

  # @return [Array<String>]
  def parameters; end

  # @param api_map [ApiMap]
  # @return [void]
  def rebind(api_map); end

  # The signature of the method that receives this block.
  #
  # @return [Parser::AST::Node]
  def receiver; end

  private

  # @param api_map [ApiMap]
  # @return [ComplexType, nil]
  def binder_or_nil(api_map); end
end

class Solargraph::Pin::ClassVariable < ::Solargraph::Pin::BaseVariable; end

class Solargraph::Pin::Closure < ::Solargraph::Pin::Base
  # @return [Closure] a new instance of Closure
  def initialize(scope: T.unsafe(nil), **splat); end

  def binder; end
  def context; end

  # @return [Array<String>]
  def gates; end

  # @return [::Symbol] :class or :instance
  def scope; end
end

module Solargraph::Pin::Common
  # @return [ComplexType]
  def binder; end

  # @return [Pin::Base, nil]
  def closure; end

  # @return [String]
  def comments; end

  # @return [ComplexType]
  def context; end

  # @return [ComplexType]
  def full_context; end

  # @return [Location]
  def location; end

  # @return [String]
  def name; end

  # @return [String]
  def namespace; end

  # @return [String]
  def path; end

  # @return [ComplexType]
  def return_type; end

  private

  # @return [ComplexType]
  def find_context; end
end

class Solargraph::Pin::Constant < ::Solargraph::Pin::BaseVariable
  # @return [Constant] a new instance of Constant
  def initialize(visibility: T.unsafe(nil), **splat); end

  def completion_item_kind; end
  def path; end
  def return_type; end

  # @return [Integer]
  def symbol_kind; end

  # Returns the value of attribute visibility.
  def visibility; end

  private

  # @return [ComplexType]
  def generate_complex_type; end
end

# @todo Move this stuff. It should be the responsibility of the language server.
module Solargraph::Pin::Conversions
  # @return [Hash]
  def completion_item; end

  # @return [String]
  def detail; end

  # Get a markdown-flavored link to a documentation page.
  #
  # @return [String]
  def link_documentation; end

  def reset_conversions; end

  # @return [Hash]
  def resolve_completion_item; end

  # @return [Hash]
  def signature_help; end

  def text_documentation; end

  private

  # @param text [String]
  # @return [String]
  def escape_brackets(text); end

  # @return [String]
  def generate_link; end
end

# A module to add the Pin::Base#documentation method.
module Solargraph::Pin::Documenting
  # @return [String]
  def documentation; end

  private

  # @param text [String]
  # @return [String]
  def normalize_indentation(text); end

  # @param line [String]
  # @return [String]
  def remove_odd_spaces(line); end
end

# A documentation formatter that either performs Markdown conversion for
# text, or applies backticks for code blocks.
class Solargraph::Pin::Documenting::DocSection
  # @param code [Boolean] True if this section is a code block
  # @return [DocSection] a new instance of DocSection
  def initialize(code); end

  # @return [Boolean]
  def code?; end

  # @param text [String]
  # @return [String]
  def concat(text); end

  # @return [String]
  def plaintext; end

  def to_s; end

  private

  # @param text [String]
  # @return [String]
  def escape_brackets(text); end

  # @param text [String]
  # @return [String]
  def unescape_brackets(text); end
end

# DuckMethod pins are used to add completion items for type tags that
# use duck typing, e.g., `@param file [#read]`.
class Solargraph::Pin::DuckMethod < ::Solargraph::Pin::Method; end

class Solargraph::Pin::GlobalVariable < ::Solargraph::Pin::BaseVariable; end

class Solargraph::Pin::InstanceVariable < ::Solargraph::Pin::BaseVariable
  def binder; end
  def context; end

  # @return [Boolean]
  def nearly?(other); end

  def scope; end
end

class Solargraph::Pin::Keyword < ::Solargraph::Pin::Base
  # @return [Keyword] a new instance of Keyword
  def initialize(name); end

  def name; end
end

class Solargraph::Pin::KeywordParam < ::Solargraph::Pin::Symbol; end

class Solargraph::Pin::LocalVariable < ::Solargraph::Pin::BaseVariable
  # @return [LocalVariable] a new instance of LocalVariable
  def initialize(assignment: T.unsafe(nil), presence: T.unsafe(nil), **splat); end

  # @return [Range]
  def presence; end

  def try_merge!(pin); end

  # @param other_closure [Pin::Closure]
  # @param other_loc [Location]
  # @return [Boolean]
  def visible_at?(other_closure, other_loc); end

  private

  def match_named_closure(needle, haystack); end

  # @param tag1 [String]
  # @param tag2 [String]
  # @return [Boolean]
  def match_tags(tag1, tag2); end
end

# The base class for method and attribute pins.
class Solargraph::Pin::Method < ::Solargraph::Pin::Closure
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  # @param visibility [::Symbol] :public, :protected, or :private
  # @param explicit [Boolean]
  # @return [Method] a new instance of Method
  def initialize(visibility: T.unsafe(nil), explicit: T.unsafe(nil), parameters: T.unsafe(nil), node: T.unsafe(nil), attribute: T.unsafe(nil), **splat); end

  # @return [Boolean]
  def attribute?; end

  def completion_item_kind; end
  def documentation; end

  # @return [Boolean]
  def explicit?; end

  # @return [Boolean]
  def nearly?(other); end

  # @return [Parser::AST::Node]
  def node; end

  # @return [Array<Pin::Method>]
  def overloads; end

  # @return [Array<String>]
  def parameter_names; end

  # @return [Array<Pin::Parameter>]
  def parameters; end

  def path; end
  def probe(api_map); end
  def return_type; end
  def symbol_kind; end
  def try_merge!(pin); end
  def typify(api_map); end

  # @return [::Symbol] :public, :private, or :protected
  def visibility; end

  private

  # @return [ComplexType]
  def generate_complex_type; end

  def infer_from_iv(api_map); end

  # @param api_map [ApiMap]
  # @return [ComplexType]
  def infer_from_return_nodes(api_map); end

  # @return [Parser::AST::Node, nil]
  def method_body_node; end

  # @param ref [String]
  # @param api_map [ApiMap]
  # @return [ComplexType]
  def resolve_reference(ref, api_map); end

  # @param api_map [ApiMap]
  # @return [ComplexType, nil]
  def see_reference(api_map); end

  # @param api_map [ApiMap]
  # @return [ComplexType, nil]
  def typify_from_super(api_map); end
end

# Use this class to track method aliases for later remapping. Common
# examples that defer mapping are aliases for superclass methods or
# methods from included modules.
class Solargraph::Pin::MethodAlias < ::Solargraph::Pin::Method
  # @return [MethodAlias] a new instance of MethodAlias
  def initialize(scope: T.unsafe(nil), original: T.unsafe(nil), **splat); end

  # @return [String]
  def original; end

  def path; end

  # @return [::Symbol]
  def scope; end

  def visibility; end
end

class Solargraph::Pin::Namespace < ::Solargraph::Pin::Closure
  # @param type [::Symbol] :class or :module
  # @param visibility [::Symbol] :public or :private
  # @param gates [Array<String>]
  # @return [Namespace] a new instance of Namespace
  def initialize(type: T.unsafe(nil), visibility: T.unsafe(nil), gates: T.unsafe(nil), **splat); end

  def binder; end
  def completion_item_kind; end
  def domains; end
  def full_context; end
  def gates; end
  def namespace; end
  def path; end
  def return_type; end
  def scope; end

  # @return [Integer]
  def symbol_kind; end

  # @return [::Symbol] :class or :module
  def type; end

  def typify(api_map); end

  # @return [::Symbol] :public or :private
  def visibility; end
end

class Solargraph::Pin::Parameter < ::Solargraph::Pin::LocalVariable
  # @return [Parameter] a new instance of Parameter
  def initialize(decl: T.unsafe(nil), asgn_code: T.unsafe(nil), **splat); end

  # Returns the value of attribute asgn_code.
  def asgn_code; end

  # Returns the value of attribute decl.
  def decl; end

  def documentation; end
  def full; end

  # The parameter's zero-based location in the block's signature.
  #
  # @return [Integer]
  def index; end

  # @return [Boolean]
  def keyword?; end

  # @return [Boolean]
  def kwrestarg?; end

  def probe(api_map); end

  # @return [Boolean]
  def rest?; end

  # @return [Boolean]
  def restarg?; end

  def return_type; end
  def try_merge!(pin); end

  # @param api_map [ApiMap]
  def typify(api_map); end

  private

  # @return [YARD::Tags::Tag]
  def param_tag; end

  # @param ref [String]
  # @param api_map [ApiMap]
  # @param skip [Array]
  # @return [Array<YARD::Tags::Tag>, nil]
  def resolve_reference(ref, api_map, skip); end

  # @param heredoc [YARD::Docstring]
  # @param api_map [ApiMap]
  # @param skip [Array]
  # @return [Array<YARD::Tags::Tag>]
  def see_reference(heredoc, api_map, skip = T.unsafe(nil)); end

  # @param api_map [ApiMap]
  # @return [ComplexType]
  def typify_block_param(api_map); end

  # @param api_map [ApiMap]
  # @return [ComplexType]
  def typify_method_param(api_map); end
end

class Solargraph::Pin::ProxyType < ::Solargraph::Pin::Base
  # @param return_type [ComplexType]
  # @return [ProxyType] a new instance of ProxyType
  def initialize(return_type: T.unsafe(nil), **splat); end

  def context; end

  class << self
    # @param return_type [ComplexType]
    # @return [ProxyType]
    def anonymous(return_type); end
  end
end

Solargraph::Pin::ROOT_PIN = T.let(T.unsafe(nil), Solargraph::Pin::Namespace)
class Solargraph::Pin::Reference < ::Solargraph::Pin::Base; end
class Solargraph::Pin::Reference::Extend < ::Solargraph::Pin::Reference; end
class Solargraph::Pin::Reference::Include < ::Solargraph::Pin::Reference; end

class Solargraph::Pin::Reference::Override < ::Solargraph::Pin::Reference
  # @return [Override] a new instance of Override
  def initialize(location, name, tags, delete = T.unsafe(nil)); end

  # @return [Array<Symbol>]
  def delete; end

  # @return [Array<YARD::Tags::Tag>]
  def tags; end

  class << self
    def from_comment(name, comment); end
    def method_return(name, *tags, delete: T.unsafe(nil)); end
  end
end

class Solargraph::Pin::Reference::Prepend < ::Solargraph::Pin::Reference; end

class Solargraph::Pin::Reference::Require < ::Solargraph::Pin::Reference
  # @return [Require] a new instance of Require
  def initialize(location, name); end
end

class Solargraph::Pin::Reference::Superclass < ::Solargraph::Pin::Reference; end

class Solargraph::Pin::Singleton < ::Solargraph::Pin::Closure
  # @return [Singleton] a new instance of Singleton
  def initialize(name: T.unsafe(nil), location: T.unsafe(nil), closure: T.unsafe(nil)); end
end

class Solargraph::Pin::Symbol < ::Solargraph::Pin::Base
  # @param location [Solargraph::Location]
  # @param name [String]
  # @return [Symbol] a new instance of Symbol
  def initialize(location, name); end

  def comments; end
  def completion_item_kind; end

  # @return [Boolean]
  def deprecated?; end

  def directives; end
  def namespace; end
  def path; end
  def return_type; end
  def visibility; end
end

# The zero-based line and column numbers of a position in a string.
class Solargraph::Position
  # @param line [Integer]
  # @param character [Integer]
  # @return [Position] a new instance of Position
  def initialize(line, character); end

  def ==(other); end

  # @return [Integer]
  def character; end

  # @return [Integer]
  def column; end

  def inspect; end

  # @return [Integer]
  def line; end

  # Get a hash of the position. This representation is suitable for use in
  # the language server protocol.
  #
  # @return [Hash]
  def to_hash; end

  class << self
    # Get a position for the specified text and offset.
    #
    # @param text [String]
    # @param offset [Integer]
    # @raise [InvalidOffsetError]
    # @return [Position]
    def from_offset(text, offset); end

    # Get a numeric offset for the specified text and a position identified
    # by its line and character.
    #
    # @param text [String]
    # @param line [Integer]
    # @param character [Integer]
    # @return [Integer]
    def line_char_to_offset(text, line, character); end

    # A helper method for generating positions from arrays of integers. The
    # original parameter is returned if it is already a position.
    #
    # @param object [Position, Array(Integer, Integer)]
    # @raise [ArgumentError] if the object cannot be converted to a position.
    # @return [Position]
    def normalize(object); end

    # Get a numeric offset for the specified text and position.
    #
    # @param text [String]
    # @param position [Position]
    # @return [Integer]
    def to_offset(text, position); end
  end
end

# A pair of positions that compose a section of text.
class Solargraph::Range
  # @param start [Position]
  # @param ending [Position]
  # @return [Range] a new instance of Range
  def initialize(start, ending); end

  def ==(other); end

  # True if the specified position is inside the range.
  #
  # @param position [Position, Array(Integer, Integer)]
  # @return [Boolean]
  def contain?(position); end

  # @return [Position]
  def ending; end

  # True if the range contains the specified position and the position does not precede it.
  #
  # @param position [Position, Array(Integer, Integer)]
  # @return [Boolean]
  def include?(position); end

  def inspect; end

  # @return [Position]
  def start; end

  # Get a hash of the range. This representation is suitable for use in
  # the language server protocol.
  #
  # @return [Hash<Symbol, Position>]
  def to_hash; end

  class << self
    # Get a range from a Parser range, usually found in
    # Parser::AST::Node#location#expression.
    #
    # @param expr [Parser::Source::Range]
    # @return [Range]
    def from_expr(expr); end

    # Get a range from a node.
    #
    # @param node [RubyVM::AbstractSyntaxTree::Node, Parser::AST::Node]
    # @return [Range]
    def from_node(node); end

    # Create a range from a pair of lines and characters.
    #
    # @param l1 [Integer] Starting line
    # @param c1 [Integer] Starting character
    # @param l2 [Integer] Ending line
    # @param c2 [Integer] Ending character
    # @return [Range]
    def from_to(l1, c1, l2, c2); end
  end
end

module Solargraph::ServerMethods
  # @return [Integer]
  def available_port; end
end

class Solargraph::Shell < ::Thor
  include ::Solargraph::ServerMethods

  def available_cores; end
  def bundle; end
  def clear; end
  def config(directory = T.unsafe(nil)); end
  def download_core(version = T.unsafe(nil)); end
  def list_cores; end
  def rdoc(gem, version = T.unsafe(nil)); end
  def reporters; end
  def scan; end
  def socket; end
  def stdio; end
  def typecheck(*files); end

  # @raise [ArgumentError]
  def uncache(*gems); end

  def version; end

  private

  # @param pin [Solargraph::Pin::Base]
  # @return [String]
  def pin_description(pin); end
end

# A Ruby file that has been parsed into an AST.
class Solargraph::Source
  include ::Solargraph::Source::EncodingFixes

  # @param code [String]
  # @param filename [String]
  # @param version [Integer]
  # @return [Source] a new instance of Source
  def initialize(code, filename = T.unsafe(nil), version = T.unsafe(nil)); end

  # Get a hash of comments grouped by the line numbers of the associated code.
  #
  # @return [Hash{Integer => Array<Parser::Source::Comment>}]
  def associated_comments; end

  # @param range [Solargraph::Range]
  # @return [String]
  def at(range); end

  # @return [String]
  def code; end

  # @param node [Parser::AST::Node]
  # @return [String]
  def code_for(node); end

  # @param position [Position]
  # @return [Boolean]
  def comment_at?(position); end

  # @return [Hash{Integer => Array<String>}]
  def comments; end

  # @param node [Parser::AST::Node]
  # @return [String]
  def comments_for(node); end

  # @param position [Position, Array(Integer, Integer)]
  # @return [Source::Cursor]
  def cursor_at(position); end

  # @return [Array<Range>]
  def error_ranges; end

  # @return [String]
  def filename; end

  # Finish synchronizing a source that was updated via #start_synchronize.
  # This method returns self if the source is already synchronized. Otherwise
  # it parses the AST and returns a new synchronized Source.
  #
  # @return [Source]
  def finish_synchronize; end

  # Get an array of ranges that can be folded, e.g., the range of a class
  # definition or an if condition.
  #
  # See FOLDING_NODE_TYPES for the list of node types that can be folded.
  #
  # @return [Array<Range>]
  def folding_ranges; end

  # @param l1 [Integer]
  # @param c1 [Integer]
  # @param l2 [Integer]
  # @param c2 [Integer]
  # @return [String]
  def from_to(l1, c1, l2, c2); end

  # A location representing the file in its entirety.
  #
  # @return [Location]
  def location; end

  # @return [Parser::AST::Node]
  def node; end

  # Get the nearest node that contains the specified index.
  #
  # @param line [Integer]
  # @param column [Integer]
  # @return [AST::Node]
  def node_at(line, column); end

  # @return [Boolean]
  def parsed?; end

  # @param name [String]
  # @return [Array<Location>]
  def references(name); end

  # @return [Boolean]
  def repaired?; end

  # Start synchronizing the source. This method updates the code without
  # parsing a new AST. The resulting Source object will be marked not
  # synchronized (#synchronized? == false).
  #
  # @param updater [Source::Updater]
  # @return [Source]
  def start_synchronize(updater); end

  # @param position [Position]
  # @return [Boolean]
  def string_at?(position); end

  def string_ranges; end

  # Synchronize the Source with an update. This method applies changes to the
  # code, parses the new code's AST, and returns the resulting Source object.
  #
  # @param updater [Source::Updater]
  # @return [Source]
  def synchronize(updater); end

  # @return [Boolean]
  def synchronized?; end

  # Get an array of nodes containing the specified index, starting with the
  # nearest node and ending with the root.
  #
  # @param line [Integer]
  # @param column [Integer]
  # @return [Array<AST::Node>]
  def tree_at(line, column); end

  # @return [Integer]
  # @todo Deprecate?
  def version; end

  protected

  # @param val [String]
  # @return [String]
  def code=(val); end

  # @return [Array<Parser::Source::Comment>]
  def comments=(_arg0); end

  # @return [Array<Range>]
  def error_ranges=(_arg0); end

  # @return [String]
  def filename=(_arg0); end

  # @return [Source::Updater]
  def last_updater; end

  # @return [Source::Updater]
  def last_updater=(_arg0); end

  # @return [Parser::AST::Node]
  def node=(_arg0); end

  # @return [Boolean]
  def parsed=(_arg0); end

  # @return [String]
  def repaired; end

  # @return [String]
  def repaired=(_arg0); end

  # @return [Boolean]
  def synchronized=(_arg0); end

  # @return [Integer]
  def version=(_arg0); end

  private

  # @return [Array<String>]
  def code_lines; end

  def colonized(range, position, node); end

  # @return [Array<Range>]
  def comment_ranges; end

  def first_not_empty_from(line); end

  # Get an array of foldable comment block ranges. Blocks are excluded if
  # they are less than 3 lines long.
  #
  # @return [Array<Range>]
  def foldable_comment_block_ranges; end

  # @param top [Parser::AST::Node]
  # @param result [Array<Range>]
  # @param parent [Symbol]
  # @return [void]
  def inner_folding_ranges(top, result = T.unsafe(nil), parent = T.unsafe(nil)); end

  # @param node [Parser::AST::Node]
  # @param position [Position]
  # @param stack [Array<Parser::AST::Node>]
  # @return [void]
  def inner_tree_at(node, position, stack); end

  # @return [Array<Parser::AST::Node>]
  def string_nodes; end

  # @param n [Parser::AST::Node]
  # @return [Array<Parser::AST::Node>]
  def string_nodes_in(n); end

  # A hash of line numbers and their associated comments.
  #
  # @return [Hash{Integer => Array<String>}]
  def stringified_comments; end

  # Get a string representation of an array of comments.
  #
  # @param comments [String]
  # @return [String]
  def stringify_comment_array(comments); end

  class << self
    # @param filename [String]
    # @return [Solargraph::Source]
    def load(filename); end

    # @param code [String]
    # @param filename [String]
    # @param version [Integer]
    # @return [Solargraph::Source]
    def load_string(code, filename = T.unsafe(nil), version = T.unsafe(nil)); end

    # @param comments [String]
    # @return [YARD::DocstringParser]
    def parse_docstring(comments); end
  end
end

# A chain of constants, variables, and method calls for inferring types of
# values.
class Solargraph::Source::Chain
  # @param links [Array<Chain::Link>]
  # @return [Chain] a new instance of Chain
  def initialize(links, node = T.unsafe(nil), splat = T.unsafe(nil)); end

  # @return [Chain]
  def base; end

  # @return [Boolean]
  def constant?; end

  # @param api_map [ApiMap]
  # @param name_pin [Pin::Base]
  # @param locals [Array<Pin::Base>]
  # @return [Array<Pin::Base>]
  def define(api_map, name_pin, locals); end

  # @return [Boolean]
  def defined?; end

  # @param api_map [ApiMap]
  # @param name_pin [Pin::Base]
  # @param locals [Array<Pin::Base>]
  # @return [ComplexType]
  def infer(api_map, name_pin, locals); end

  # @return [Array<Source::Chain::Link>]
  def links; end

  # @return [Boolean]
  def literal?; end

  # Returns the value of attribute node.
  def node; end

  # @return [Boolean]
  def nullable?; end

  # @return [Boolean]
  def splat?; end

  # @return [Boolean]
  def undefined?; end

  private

  # @param pins [Array<Pin::Base>]
  # @param api_map [ApiMap]
  # @return [ComplexType]
  def infer_first_defined(pins, context, api_map); end

  # @param type [ComplexType]
  def maybe_nil(type); end
end

class Solargraph::Source::Chain::BlockVariable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::Call < ::Solargraph::Source::Chain::Link
  # @param word [String]
  # @param arguments [Array<Chain>]
  # @param with_block [Boolean] True if the chain is inside a block
  # @param head [Boolean] True if the call is the start of its chain
  # @return [Call] a new instance of Call
  def initialize(word, arguments = T.unsafe(nil), with_block = T.unsafe(nil)); end

  # @return [Array<Chain>]
  def arguments; end

  # @param api_map [ApiMap]
  # @param name_pin [Pin::Base]
  # @param locals [Array<Pin::Base>]
  def resolve(api_map, name_pin, locals); end

  # @return [Boolean]
  def with_block?; end

  # @return [String]
  def word; end

  private

  # @param arguments [Array<Chain>]
  # @param parameters [Array<String>]
  # @return [Boolean]
  def arguments_match(arguments, parameters); end

  # @param docstring [YARD::Docstring]
  # @param context [ComplexType]
  # @return [ComplexType]
  def extra_return_type(docstring, context); end

  # @param pins [Array<Pin::Base>]
  # @param api_map [ApiMap]
  # @param context [ComplexType]
  # @param locals [Pin::LocalVariable]
  # @return [Array<Pin::Base>]
  def inferred_pins(pins, api_map, context, locals); end

  # @param pin [Pin]
  # @param macro [YARD::Tags::MacroDirective]
  # @param api_map [ApiMap]
  # @param context [ComplexType]
  # @param locals [Array<Pin::Base>]
  # @return [Pin::ProxyType]
  def inner_process_macro(pin, macro, api_map, context, locals); end

  # @param pin [Pin::Method]
  # @param api_map [ApiMap]
  # @param context [ComplexType]
  # @param locals [Pin::Base]
  # @return [Pin::ProxyType]
  def process_directive(pin, api_map, context, locals); end

  # @param pin [Pin::Method]
  # @param api_map [ApiMap]
  # @param context [ComplexType]
  # @param locals [Pin::Base]
  # @return [Pin::Base]
  def process_macro(pin, api_map, context, locals); end

  # @param api_map [ApiMap]
  # @param name_pin [Pin::Base]
  # @return [Array<Pin::Base>]
  def super_pins(api_map, name_pin); end
end

class Solargraph::Source::Chain::ClassVariable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::Constant < ::Solargraph::Source::Chain::Link
  # @return [Constant] a new instance of Constant
  def initialize(word); end

  def resolve(api_map, name_pin, locals); end

  private

  def crawl_gates(pin); end
  def deep_constant_type(gate, api_map); end
  def first_pin_type(pins, api_map); end
end

class Solargraph::Source::Chain::GlobalVariable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::Hash < ::Solargraph::Source::Chain::Literal
  # @param type [String]
  # @param splatted [Boolean]
  # @return [Hash] a new instance of Hash
  def initialize(type, splatted = T.unsafe(nil)); end

  def resolve(api_map, name_pin, locals); end

  # @return [Boolean]
  def splatted?; end

  def word; end
end

# Chain::Head is a link for ambiguous words, e.g.; `String` can refer to
# either a class (`String`) or a function (`Kernel#String`).
#
# @note Chain::Head is only intended to handle `self` and `super`.
class Solargraph::Source::Chain::Head < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::InstanceVariable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::Link
  # @return [Link] a new instance of Link
  def initialize(word = T.unsafe(nil)); end

  def ==(other); end

  # Make a copy of this link unmarked as the head of a chain
  #
  # @return [self]
  def clone_body; end

  # Make a copy of this link marked as the head of a chain
  #
  # @return [self]
  def clone_head; end

  # @return [Boolean]
  def constant?; end

  # @return [Boolean]
  def head?; end

  # Returns the value of attribute last_context.
  def last_context; end

  # Sets the attribute last_context
  #
  # @param value the value to set the attribute last_context to.
  def last_context=(_arg0); end

  # @return [Boolean]
  def nullable?; end

  # @param api_map [ApiMap]
  # @param name_pin [Pin::Base]
  # @param locals [Array<Pin::Base>]
  # @return [Array<Pin::Base>]
  def resolve(api_map, name_pin, locals); end

  # @return [Boolean]
  def undefined?; end

  # @return [String]
  def word; end

  protected

  # Mark whether this link is the head of a chain
  #
  # @param bool [Boolean]
  # @return [self]
  def mark_head(bool); end
end

class Solargraph::Source::Chain::Literal < ::Solargraph::Source::Chain::Link
  # @param type [String]
  # @return [Literal] a new instance of Literal
  def initialize(type); end

  def resolve(api_map, name_pin, locals); end
  def word; end
end

class Solargraph::Source::Chain::Or < ::Solargraph::Source::Chain::Link
  # @param type [String]
  # @return [Or] a new instance of Or
  def initialize(links); end

  def resolve(api_map, name_pin, locals); end
  def word; end
end

class Solargraph::Source::Chain::QCall < ::Solargraph::Source::Chain::Call
  # @return [Boolean]
  def nullable?; end
end

Solargraph::Source::Chain::UNDEFINED_CALL = T.let(T.unsafe(nil), Solargraph::Source::Chain::Call)
Solargraph::Source::Chain::UNDEFINED_CONSTANT = T.let(T.unsafe(nil), Solargraph::Source::Chain::Constant)

class Solargraph::Source::Chain::Variable < ::Solargraph::Source::Chain::Link
  def resolve(api_map, name_pin, locals); end
end

class Solargraph::Source::Chain::ZSuper < ::Solargraph::Source::Chain::Call
  # @param word [String]
  # @param arguments [Array<Chain>]
  # @param with_block [Boolean] True if the chain is inside a block
  # @param head [Boolean] True if the call is the start of its chain
  # @return [ZSuper] a new instance of ZSuper
  def initialize(word, with_block = T.unsafe(nil)); end

  # @return [Array<Chain>]
  def arguments; end

  # @param api_map [ApiMap]
  # @param name_pin [Pin::Base]
  # @param locals [Array<Pin::Base>]
  def resolve(api_map, name_pin, locals); end

  # @return [String]
  def word; end
end

# A change to be applied to text.
class Solargraph::Source::Change
  include ::Solargraph::Source::EncodingFixes

  # @param range [Range] The starting and ending positions of the change.
  #   If nil, the original text will be overwritten.
  # @param new_text [String] The text to be changed.
  # @return [Change] a new instance of Change
  def initialize(range, new_text); end

  # @return [String]
  def new_text; end

  # @return [Range]
  def range; end

  # Repair an update by replacing the new text with similarly formatted
  # whitespace.
  #
  # @param text [String] The text to be changed.
  # @return [String] The updated text.
  def repair(text); end

  # Write the change to the specified text.
  #
  # @param text [String] The text to be changed.
  # @param nullable [Boolean] If true, minor changes that could generate
  #   syntax errors will be repaired.
  # @return [String] The updated text.
  def write(text, nullable = T.unsafe(nil)); end

  private

  def commit(text, insert); end
end

# Information about a position in a source, including the word located
# there.
class Solargraph::Source::Cursor
  # @param source [Source]
  # @param position [Position, Array(Integer, Integer)]
  # @return [Cursor] a new instance of Cursor
  def initialize(source, position); end

  # True if the statement at the cursor is an argument to a previous
  # method.
  #
  # Given the code `process(foo)`, a cursor pointing at `foo` would
  # identify it as an argument being passed to the `process` method.
  #
  # If #argument? is true, the #recipient method will return a cursor that
  # points to the method receiving the argument.
  #
  # @return [Boolean]
  def argument?; end

  # @return [Chain]
  def chain; end

  # @return [Boolean]
  def comment?; end

  # The part of the word after the current position. Given the text
  # `foo.bar`, the end_of_word at position (0,6) is `r`.
  #
  # @return [String]
  def end_of_word; end

  # @return [String]
  def filename; end

  def node; end

  # @return [Position]
  def node_position; end

  # @return [Integer]
  def offset; end

  # @return [Position]
  def position; end

  # The range of the word at the current position.
  #
  # @return [Range]
  def range; end

  # Get a cursor pointing to the method that receives the current statement
  # as an argument.
  #
  # @return [Cursor, nil]
  def receiver; end

  # Get a cursor pointing to the method that receives the current statement
  # as an argument.
  #
  # @return [Cursor, nil]
  def recipient; end

  def recipient_node; end

  # @return [Source]
  def source; end

  # @return [Boolean]
  def start_of_constant?; end

  # The part of the word before the current position. Given the text
  # `foo.bar`, the start_of_word at position(0, 6) is `ba`.
  #
  # @return [String]
  def start_of_word; end

  # @return [Boolean]
  def string?; end

  # The whole word at the current position. Given the text `foo.bar`, the
  # word at position(0,6) is `bar`.
  #
  # @return [String]
  def word; end

  private

  # A regular expression to find the end of a word from an offset.
  #
  # @return [Regexp]
  def end_word_pattern; end

  # A regular expression to find the start of a word from an offset.
  #
  # @return [Regexp]
  def start_word_pattern; end
end

module Solargraph::Source::EncodingFixes
  private

  # Convert strings to normalized UTF-8.
  #
  # @param string [String]
  # @return [String]
  def normalize(string); end

  class << self
    # Convert strings to normalized UTF-8.
    #
    # @param string [String]
    # @return [String]
    def normalize(string); end
  end
end

Solargraph::Source::FOLDING_NODE_TYPES = T.let(T.unsafe(nil), Array)

# Information about a location in a source, including the location's word
# and signature, literal values at the base of signatures, and whether the
# location is inside a string or comment. ApiMaps use Fragments to provide
# results for completion and definition queries.
class Solargraph::Source::SourceChainer
  # @param source [Source]
  # @param position [Position]
  # @return [SourceChainer] a new instance of SourceChainer
  def initialize(source, position); end

  # @return [Source::Chain]
  def chain; end

  private

  # @return [String]
  def end_of_phrase; end

  # @return [String]
  def fixed_phrase; end

  # @return [Position]
  def fixed_position; end

  # @param line [Integer]
  # @param column [Integer]
  # @return [Integer]
  def get_offset(line, column); end

  def get_signature_data_at(index); end

  # @return [Integer]
  def offset; end

  # @return [String]
  def phrase; end

  # @return [Position]
  def position; end

  def signature_data; end

  # @return [Solargraph::Source]
  def source; end

  # True if the current offset is inside a string.
  #
  # @return [Boolean]
  def string?; end

  class << self
    # @param source [Source]
    # @param position [Position]
    # @return [Source::Chain]
    def chain(source, position); end
  end
end

# Updaters contain changes to be applied to a source. The source applies
# the update via the Source#synchronize method.
class Solargraph::Source::Updater
  # @param filename [String] The file to update.
  # @param version [Integer] A version number associated with this update.
  # @param changes [Array<Solargraph::Source::Change>] The changes.
  # @return [Updater] a new instance of Updater
  def initialize(filename, version, changes); end

  # @return [Array<Change>]
  def changes; end

  # @return [String]
  def filename; end

  # @return [String]
  def repair(text); end

  # @return [Integer]
  def version; end

  # @param text [String]
  # @param nullable [Boolean]
  # @return [String]
  def write(text, nullable = T.unsafe(nil)); end
end

# An index of pins and other ApiMap-related data for a Source.
class Solargraph::SourceMap
  # @param source [Source]
  # @param pins [Array<Pin::Base>]
  # @param locals [Array<Pin::Base>]
  # @return [SourceMap] a new instance of SourceMap
  def initialize(source, pins, locals); end

  # @return [String]
  def code; end

  # @param position [Position]
  # @return [Source::Cursor]
  def cursor_at(position); end

  # @return [Array<Pin::Base>]
  def document_symbols; end

  # @return [Environ]
  def environ; end

  # @return [String]
  def filename; end

  # @param path [String]
  # @return [Pin::Base]
  def first_pin(path); end

  # @return [Array<Pin::Base>]
  def locals; end

  # @param location [Location]
  # @return [Array<Pin::LocalVariable>]
  def locals_at(location); end

  def locate_block_pin(line, character); end
  def locate_named_path_pin(line, character); end

  # @param location [Solargraph::Location]
  # @return [Array<Solargraph::Pin::Base>]
  def locate_pins(location); end

  # @return [Array<Pin::Base>]
  def pins; end

  def pins_by_class(klass); end

  # @param query [String]
  # @return [Array<Pin::Base>]
  def query_symbols(query); end

  def rebindable_method_names; end

  # @param name [String]
  # @return [Array<Location>]
  def references(name); end

  # @return [Array<Pin::Reference::Require>]
  def requires; end

  # @return [Source]
  def source; end

  # @param other_map [SourceMap]
  # @return [Boolean]
  def try_merge!(other_map); end

  private

  # @param line [Integer]
  # @param character [Integer]
  # @param klasses [Array<Class>]
  # @return [Pin::Base]
  def _locate_pin(line, character, *klasses); end

  # @param str1 [String]
  # @param str2 [String]
  # @return [Boolean]
  def fuzzy_string_match(str1, str2); end

  class << self
    # @param filename [String]
    # @return [SourceMap]
    def load(filename); end

    # @param code [String]
    # @param filename [String, nil]
    # @return [SourceMap]
    def load_string(code, filename = T.unsafe(nil)); end

    # @param source [Source]
    # @return [SourceMap]
    def map(source); end
  end
end

# A static analysis tool for obtaining definitions, completions,
# signatures, and type inferences from a cursor.
class Solargraph::SourceMap::Clip
  # @param api_map [ApiMap]
  # @param cursor [Source::Cursor]
  # @return [Clip] a new instance of Clip
  def initialize(api_map, cursor); end

  # @return [Completion]
  def complete; end

  # @return [Array<Pin::Base>]
  def define; end

  def gates; end

  # @return [Boolean]
  def in_block?; end

  # @return [ComplexType]
  def infer; end

  # Get an array of all the locals that are visible from the cursors's
  # position. Locals can be local variables, method parameters, or block
  # parameters. The array starts with the nearest local pin.
  #
  # @return [Array<Solargraph::Pin::Base>]
  def locals; end

  # @return [Array<Pin::Base>]
  def signify; end

  # @param phrase [String]
  # @return [Array<Solargraph::Pin::Base>]
  def translate(phrase); end

  private

  # @return [ApiMap]
  def api_map; end

  # @return [Solargraph::Pin::Base]
  def block; end

  def code_complete; end

  # @return [Array<Pin::KeywordParam]] Array<Pin::KeywordParam]
  def complete_keyword_parameters; end

  # The context at the current position.
  #
  # @return [Pin::Base]
  def context_pin; end

  # @return [Source::Cursor]
  def cursor; end

  def location; end

  # @param result [Array<Pin::Base>]
  # @return [Completion]
  def package_completions(result); end

  # @return [SourceMap]
  def source_map; end

  def tag_complete; end

  # @return [Array<Pin::Base>]
  def yielded_self_pins; end
end

# The result of a completion request containing the pins that describe
# completion options and the range to be replaced.
class Solargraph::SourceMap::Completion
  # @param pins [Array<Solargraph::Pin::Base>]
  # @param range [Solargraph::Range]
  # @return [Completion] a new instance of Completion
  def initialize(pins, range); end

  # @return [Array<Solargraph::Pin::Base>]
  def pins; end

  # @return [Solargraph::Range]
  def range; end
end

# The Mapper generates pins and other data for SourceMaps.
#
# This class is used internally by the SourceMap class. Users should not
# normally need to call it directly.
class Solargraph::SourceMap::Mapper
  def closure_at(position); end

  # @param comment [String]
  # @return [Integer]
  def find_directive_line_number(comment, tag, start); end

  # Generate the data.
  #
  # @param source [Source]
  # @return [Array]
  def map(source); end

  # @return [Array<Solargraph::Pin::Base>]
  def pins; end

  def process_comment(source_position, comment_position, comment); end

  # @return [void]
  def process_comment_directives; end

  # @param source_position [Position]
  # @param comment_position [Position]
  # @param directive [YARD::Tags::Directive]
  # @return [void]
  def process_directive(source_position, comment_position, directive); end

  def remove_inline_comment_hashes(comment); end

  # @param filename [String]
  # @param code [String]
  # @return [Array]
  def unmap(filename, code); end

  class << self
    # @param source [Source]
    # @return [Array]
    def map(source); end
  end
end

Solargraph::SourceMap::Mapper::MACRO_REGEXP = T.let(T.unsafe(nil), Regexp)
class Solargraph::SourceNotAvailableError < ::StandardError; end

# A static analysis tool for validating data types.
class Solargraph::TypeChecker
  include ::Solargraph::TypeChecker::Checks
  include ::Solargraph::Parser::Rubyvm::NodeMethods

  # @param filename [String]
  # @param api_map [ApiMap]
  # @param level [Symbol]
  # @return [TypeChecker] a new instance of TypeChecker
  def initialize(filename, api_map: T.unsafe(nil), level: T.unsafe(nil)); end

  # @return [ApiMap]
  def api_map; end

  # @return [String]
  def filename; end

  # @return [Array<Problem>]
  def problems; end

  # @return [Rules]
  def rules; end

  # @return [SourceMap]
  def source_map; end

  private

  # @return [Boolean]
  def abstract?(pin); end

  # @return [Array<Pin::BaseVariable>]
  def all_variables; end

  def argument_problems_for(chain, api_map, block_pin, locals, location); end

  # @param pin [Pin::Method]
  def arity_problems_for(pin, arguments, location); end

  def call_problems; end
  def const_problems; end

  # @return [Boolean]
  def declared_externally?(pin); end

  # @param pin [Pin::Base]
  # @return [Boolean]
  def external?(pin); end

  def fake_args_for(pin); end

  # @param [Array<Pin::Method>]
  # @return [Hash]
  def first_param_hash(pins); end

  def ignored_pins; end

  # @param pin [Pin::Base]
  # @return [Boolean]
  def internal?(pin); end

  # @return [Boolean]
  def internal_or_core?(pin); end

  def kwarg_problems_for(argchain, api_map, block_pin, locals, location, pin, params, first); end
  def kwrestarg_problems_for(api_map, block_pin, locals, location, pin, params, kwargs); end

  # @param pin [Pin::Method]
  # @return [Array<Problem>]
  def method_param_type_problems_for(pin); end

  # @param pin [Pin::Method]
  # @return [Array<Problem>]
  def method_return_type_problems_for(pin); end

  # @return [Array<Problem>]
  def method_tag_problems; end

  # @param pin [Pin::Method]
  def optional_param_count(pin); end

  # @param [Pin::Method]
  # @return [Hash]
  def param_hash(pin); end

  # @param pin [Pin::Method]
  def pin_arity_problems_for(pin, arguments, location); end

  # @param pin [Pin::Method]
  def required_param_count(pin); end

  # @param pin [Pin::Base]
  # @return [Boolean]
  # @todo This is not optimal. A better solution would probably be to mix
  #   namespace alias into types at the ApiMap level.
  def resolved_constant?(pin); end

  # @return [Array<Problem>]
  def variable_type_tag_problems; end

  # @return [Boolean]
  def virtual_pin?(pin); end

  class << self
    # @param filename [String]
    # @return [self]
    def load(filename, level = T.unsafe(nil)); end

    # @param code [String]
    # @param filename [String, nil]
    # @return [self]
    def load_string(code, filename = T.unsafe(nil), level = T.unsafe(nil)); end
  end
end

# Helper methods for performing type checks
module Solargraph::TypeChecker::Checks
  private

  # @param api_map [ApiMap]
  # @param expected [ComplexType]
  # @param inferred [ComplexType]
  # @return [Boolean]
  def any_types_match?(api_map, expected, inferred); end

  # @param api_map [ApiMap]
  # @param expected [ComplexType]
  # @param inferred [ComplexType]
  # @return [Boolean]
  def duck_types_match?(api_map, expected, inferred); end

  # @param api_map [ApiMap]
  # @param cls1 [ComplexType::UniqueType]
  # @param cls2 [ComplexType::UniqueType]
  # @return [Boolean]
  def either_way?(api_map, cls1, cls2); end

  # @param type [ComplexType::UniqueType]
  # @return [String]
  def fuzz(type); end

  # Compare an expected type with an inferred type. Common usage is to
  # check if the type declared in a method's @return tag matches the type
  # inferred from static analysis of the code.
  #
  # @param api_map [ApiMap]
  # @param expected [ComplexType]
  # @param inferred [ComplexType]
  # @return [Boolean]
  def types_match?(api_map, expected, inferred); end

  class << self
    # @param api_map [ApiMap]
    # @param expected [ComplexType]
    # @param inferred [ComplexType]
    # @return [Boolean]
    def any_types_match?(api_map, expected, inferred); end

    # @param api_map [ApiMap]
    # @param expected [ComplexType]
    # @param inferred [ComplexType]
    # @raise [ArgumentError]
    # @return [Boolean]
    def duck_types_match?(api_map, expected, inferred); end

    # @param api_map [ApiMap]
    # @param cls1 [ComplexType::UniqueType]
    # @param cls2 [ComplexType::UniqueType]
    # @return [Boolean]
    def either_way?(api_map, cls1, cls2); end

    # @param type [ComplexType::UniqueType]
    # @return [String]
    def fuzz(type); end

    # Compare an expected type with an inferred type. Common usage is to
    # check if the type declared in a method's @return tag matches the type
    # inferred from static analysis of the code.
    #
    # @param api_map [ApiMap]
    # @param expected [ComplexType]
    # @param inferred [ComplexType]
    # @return [Boolean]
    def types_match?(api_map, expected, inferred); end
  end
end

# Data about a method parameter definition. This is the information from
# the args list in the def call, not the `@param` tags.
class Solargraph::TypeChecker::ParamDef
  # @return [ParamDef] a new instance of ParamDef
  def initialize(name, type); end

  # @return [String]
  def name; end

  # @return [Symbol]
  def type; end

  class << self
    # Get an array of ParamDefs from a method pin.
    #
    # @param pin [Solargraph::Pin::Method]
    # @return [Array<ParamDef>]
    def from(pin); end
  end
end

# A problem reported by TypeChecker.
class Solargraph::TypeChecker::Problem
  # @param location [Solargraph::Location]
  # @param message [String]
  # @param pin [Solargraph::Pin::Base, nil]
  # @param suggestion [String, nil]
  # @return [Problem] a new instance of Problem
  def initialize(location, message, pin: T.unsafe(nil), suggestion: T.unsafe(nil)); end

  # @return [Solargraph::Location]
  def location; end

  # @return [String]
  def message; end

  # @return [Pin::Base]
  def pin; end

  # @return [String, nil]
  def suggestion; end
end

# Definitions of type checking rules to be performed at various levels
class Solargraph::TypeChecker::Rules
  # @param level [Symbol]
  # @return [Rules] a new instance of Rules
  def initialize(level); end

  # @return [Boolean]
  def ignore_all_undefined?; end

  # @return [Symbol]
  def level; end

  # @return [Boolean]
  def must_tag_or_infer?; end

  # @return [Integer]
  def rank; end

  # @return [Boolean]
  def require_type_tags?; end

  # @return [Boolean]
  def validate_calls?; end

  # @return [Boolean]
  def validate_consts?; end

  # @return [Boolean]
  def validate_tags?; end
end

Solargraph::TypeChecker::Rules::LEVELS = T.let(T.unsafe(nil), Hash)
Solargraph::VERSION = T.let(T.unsafe(nil), String)
Solargraph::VIEWS_PATH = T.let(T.unsafe(nil), String)

# A workspace consists of the files in a project's directory and the
# project's configuration. It provides a Source for each file to be used
# in an associated Library or ApiMap.
class Solargraph::Workspace
  # @param directory [String]
  # @param config [Config, nil]
  # @return [Workspace] a new instance of Workspace
  def initialize(directory = T.unsafe(nil), config = T.unsafe(nil)); end

  # @return [Solargraph::Workspace::Config]
  def config; end

  # @return [String]
  def directory; end

  # @return [Array<String>]
  def filenames; end

  # @return [Array<String>]
  def gemnames; end

  # True if the workspace contains at least one gemspec file.
  #
  # @return [Boolean]
  def gemspec?; end

  # Get an array of all gemspec files in the workspace.
  #
  # @return [Array<String>]
  def gemspecs; end

  # @param filename [String]
  # @return [Boolean]
  def has_file?(filename); end

  # Merge the source. A merge will update the existing source for the file
  # or add it to the sources if the workspace is configured to include it.
  # The source is ignored if the configuration excludes it.
  #
  # @param source [Solargraph::Source]
  # @return [Boolean] True if the source was added to the workspace
  def merge(source); end

  # Remove a source from the workspace. The source will not be removed if
  # its file exists and the workspace is configured to include it.
  #
  # @param filename [String]
  # @return [Boolean] True if the source was removed from the workspace
  def remove(filename); end

  # The require paths associated with the workspace.
  #
  # @return [Array<String>]
  def require_paths; end

  # Get a source by its filename.
  #
  # @param filename [String]
  # @return [Solargraph::Source]
  def source(filename); end

  # @return [Array<String>]
  def source_gems; end

  # @return [Array<Solargraph::Source>]
  def sources; end

  # Synchronize the workspace from the provided updater.
  #
  # @param updater [Source::Updater]
  # @return [void]
  def synchronize!(updater); end

  # Determine whether a file would be merged into the workspace.
  #
  # @param filename [String]
  # @return [Boolean]
  def would_merge?(filename); end

  # True if the path resolves to a file in the workspace's require paths.
  #
  # @param path [String]
  # @return [Boolean]
  def would_require?(path); end

  private

  # Get additional require paths defined in the configuration.
  #
  # @return [Array<String>]
  def configured_require_paths; end

  # Generate require paths from gemspecs if they exist or assume the default
  # lib directory.
  #
  # @return [Array<String>]
  def generate_require_paths; end

  # @return [void]
  def load_sources; end

  def require_plugins; end

  # @return [Hash{String => Solargraph::Source}]
  def source_hash; end
end

# Configuration data for a workspace.
class Solargraph::Workspace::Config
  # @param directory [String]
  # @return [Config] a new instance of Config
  def initialize(directory = T.unsafe(nil)); end

  # @return [Boolean]
  def allow?(filename); end

  # The calculated array of (included - excluded) files in the workspace.
  #
  # @return [Array<String>]
  def calculated; end

  # @return [String]
  def directory; end

  # An array of domains configured for the workspace.
  # A domain is a namespace that the ApiMap should include in the global
  # namespace. It's typically used to identify available DSLs.
  #
  # @return [Array<String>]
  def domains; end

  # An array of files excluded from the workspace.
  #
  # @return [Array<String>]
  def excluded; end

  # A hash of options supported by the formatter
  #
  # @return [Hash]
  def formatter; end

  # An array of files included in the workspace (before calculating excluded files).
  #
  # @return [Array<String>]
  def included; end

  # The maximum number of files to parse from the workspace.
  #
  # @return [Integer]
  def max_files; end

  # An array of plugins to require.
  #
  # @return [Array<String>]
  def plugins; end

  # @return [Hash]
  def raw_data; end

  # An array of reporters to use for diagnostics.
  #
  # @return [Array<String>]
  def reporters; end

  # An array of load paths for required paths.
  #
  # @return [Array<String>]
  def require_paths; end

  # An array of required paths to add to the workspace.
  #
  # @return [Array<String>]
  def required; end

  private

  # @return [Hash]
  def config_data; end

  # @return [Hash]
  def default_config; end

  def excluded_directories; end

  # True if the glob translates to a whole directory.
  #
  # @example
  #   glob_is_directory?('path/to/dir')       # => true
  #   glob_is_directory?('path/to/dir/**/*)   # => true
  #   glob_is_directory?('path/to/file.txt')  # => false
  #   glob_is_directory?('path/to/*.txt')     # => false
  # @param glob [String]
  # @return [Boolean]
  def glob_is_directory?(glob); end

  # Translate a glob to a base directory if applicable
  #
  # @example
  #   glob_to_directory('path/to/dir/**/*') # => 'path/to/dir'
  # @param glob [String]
  # @return [String]
  def glob_to_directory(glob); end

  # @return [String]
  def global_config_path; end

  # Modify the included files based on excluded directories and get an
  # array of additional files to exclude.
  #
  # @param globs [Array<String>]
  # @return [Array<String>]
  def process_exclusions(globs); end

  # Get an array of files from the provided globs.
  #
  # @param globs [Array<String>]
  # @return [Array<String>]
  def process_globs(globs); end

  # Read a .solargraph yaml config
  #
  # @param directory [String]
  # @return [Hash, nil]
  def read_config(config_path = T.unsafe(nil)); end

  # @return [String]
  def workspace_config_path; end
end

# The maximum number of files that can be added to a workspace.
# The workspace's .solargraph.yml can override this value.
Solargraph::Workspace::Config::MAX_FILES = T.let(T.unsafe(nil), Integer)

class Solargraph::WorkspaceTooLargeError < ::RuntimeError; end
Solargraph::YARDOC_PATH = T.let(T.unsafe(nil), String)
Solargraph::YARD_EXTENSION_FILE = T.let(T.unsafe(nil), String)

# The YardMap provides access to YARD documentation for the Ruby core, the
# stdlib, and gems.
class Solargraph::YardMap
  include ::Solargraph::ApiMap::BundlerMethods

  # @param required [Array<String>, Set<String>]
  # @param directory [String]
  # @param source_gems [Array<String>, Set<String>]
  # @param with_dependencies [Boolean]
  # @return [YardMap] a new instance of YardMap
  def initialize(required: T.unsafe(nil), directory: T.unsafe(nil), source_gems: T.unsafe(nil), with_dependencies: T.unsafe(nil)); end

  def base_required; end

  # @param new_requires [Set<String>] Required paths to use for loading gems
  # @param new_directory [String] The workspace directory
  # @param new_source_gems [Set<String>] Gems under local development (i.e., part of the workspace)
  # @return [Boolean]
  def change(new_requires, new_directory, new_source_gems); end

  # @return [Array<Solargraph::Pin::Base>]
  def core_pins; end

  def directory; end

  # @param y [String]
  # @return [YARD::Registry]
  def load_yardoc(y); end

  # @param path [String]
  # @return [Pin::Base]
  def path_pin(path); end

  # @return [Array<Solargraph::Pin::Base>]
  def pins; end

  # @return [Set<String>]
  def rebindable_method_names; end

  # Get the location of a file referenced by a require path.
  #
  # @param path [String]
  # @return [Location]
  def require_reference(path); end

  # @return [Set<String>]
  def required; end

  def stdlib_paths; end
  def stdlib_pins; end

  # @return [Array<String>]
  def unresolved_requires; end

  # @return [Boolean]
  def with_dependencies=(_arg0); end

  # @return [Boolean]
  def with_dependencies?; end

  # @return [Array<String>]
  def yardocs; end

  private

  # @param spec [Gem::Specification]
  # @return [void]
  def add_gem_dependencies(spec); end

  # @return [YardMap::Cache]
  def cache; end

  def load_core_pins; end
  def load_stdlib_pins(base); end

  # @return [Hash]
  def pin_class_hash; end

  # @return [Array<Pin::Base>]
  def pins_by_class(klass); end

  def process_gemsets; end

  # @return [void]
  def process_requires; end

  # @param y [String, nil]
  # @param spec [Gem::Specification, nil]
  # @raise [NoYardocError]
  # @return [Array<Pin::Base>]
  def process_yardoc(y, spec = T.unsafe(nil)); end

  def read_core_and_save_cache(yd, ser); end
  def read_stdlib_and_save_cache(base, ser); end

  # @param ns [YARD::CodeObjects::NamespaceObject]
  # @return [Array<YARD::CodeObjects::Base>]
  def recurse_namespace_object(ns); end

  # @param path [String]
  # @return [Gem::Specification]
  def spec_for_require(path); end

  # @param spec [Gem::Specification]
  # @return [String]
  def yardoc_file_for_spec(spec); end
end

class Solargraph::YardMap::Cache
  # @return [Cache] a new instance of Cache
  def initialize; end

  def get_path_pins(path); end
  def set_path_pins(path, pins); end
end

# Tools for managing core documentation.
module Solargraph::YardMap::CoreDocs
  class << self
    # Get a list of core documentation versions that are available for
    # download.
    #
    # @raise [SourceNotAvailableError]
    # @return [Array<String>] The version numbers
    def available; end

    # Get the version number of core documentation available for download
    # that is the closest match for the current Ruby version.
    #
    # @param current [String] The version to compare
    # @return [String] The version number of the best match
    def best_download(current = T.unsafe(nil)); end

    # Get the version number of the installed core documentation that is
    # the closest match for the current Ruby version.
    #
    # @return [String] The closest match
    def best_match; end

    # The directory where core documentation is installed.
    #
    # @return [String]
    def cache_dir; end

    # Reset the core documentation cache to the minimum requirement.
    #
    # @return [void]
    def clear; end

    # Download the specified version of core documentation.
    #
    # @param version [String]
    # @return [void]
    def download(version); end

    # Ensure installation of minimum documentation.
    #
    # @return [void]
    def require_minimum; end

    # True if core documentation is installed for the specified version
    # number.
    #
    # @param ver [String] The version number to check
    # @return [Boolean]
    def valid?(ver); end

    # Get a list of version numbers for currently installed core
    # documentation.
    #
    # @return [Array<String>] The installed version numbers
    def versions; end

    # Get the path to a yardoc file for Ruby core documentation.
    #
    # @param ver [String] The version number (best match is default)
    # @raise [ArgumentError]
    # @return [String] The path to the yardoc
    def yardoc_file(ver = T.unsafe(nil)); end

    # Get the path to a yardoc file for Ruby stdlib documentation.
    #
    # @param ver [String] The version number (best match is default)
    # @raise [ArgumentError]
    # @return [String] The path to the yardoc
    def yardoc_stdlib_file(ver = T.unsafe(nil)); end

    private

    # Extract the specified archive to the core cache directory.
    #
    # @param filename [String]
    # @return [void]
    def install_archive(filename); end
  end
end

# The default core documentation version
Solargraph::YardMap::CoreDocs::DEFAULT = T.let(T.unsafe(nil), String)

# The URL for downloading core documentation
Solargraph::YardMap::CoreDocs::SOURCE = T.let(T.unsafe(nil), String)

module Solargraph::YardMap::CoreFills; end
Solargraph::YardMap::CoreFills::ALL = T.let(T.unsafe(nil), Array)
Solargraph::YardMap::CoreFills::KEYWORDS = T.let(T.unsafe(nil), Array)
Solargraph::YardMap::CoreFills::OVERRIDES = T.let(T.unsafe(nil), Array)
Solargraph::YardMap::CoreFills::Override = Solargraph::Pin::Reference::Override
Solargraph::YardMap::CoreFills::PINS = T.let(T.unsafe(nil), Array)

# Tools for generating core documentation.
module Solargraph::YardMap::CoreGen
  class << self
    # Generate documentation from the specified Ruby source directory.
    #
    # @param ruby_dir [String] The Ruby source directory
    # @param dest_dir [String] The destination directory for the yardocs
    # @return [void]
    def generate_docs(ruby_dir, dest_dir); end

    # Generate a gzip of documentation from the specified Ruby source
    # directory.
    #
    # This method is designed to generate the directory architecture that
    # YardMap core docs expect.
    #
    # @param ruby_dir [String] The Ruby source directory
    # @param ver_name [String, nil] The version name
    # @param dest_dir [String] The destination directory
    # @return [void]
    def generate_gzip(ruby_dir, ver_name = T.unsafe(nil), dest_dir = T.unsafe(nil)); end

    private

    # @param dir [String] The directory to compress
    # @param dst [String] The destination file
    def gzip(dir, dst); end
  end
end

module Solargraph::YardMap::Helpers
  private

  # @param code_object [YARD::CodeObjects::Base]
  # @param spec [Gem::Specification]
  # @return [Solargraph::Location, nil]
  def object_location(code_object, spec); end

  class << self
    # @param code_object [YARD::CodeObjects::Base]
    # @param spec [Gem::Specification]
    # @return [Solargraph::Location, nil]
    def object_location(code_object, spec); end
  end
end

class Solargraph::YardMap::Mapper
  # @param code_objects [Array<YARD::CodeObjects::Base>]
  # @param spec [Gem::Specification]
  # @return [Mapper] a new instance of Mapper
  def initialize(code_objects, spec = T.unsafe(nil)); end

  # @return [Array<Pin::Base>]
  def map; end

  private

  # @param code_object [YARD::CodeObjects::Base]
  # @return [Array<Pin::Base>]
  def generate_pins(code_object); end
end

module Solargraph::YardMap::Mapper::ToConstant
  extend ::Solargraph::YardMap::Helpers

  class << self
    def make(code_object, closure = T.unsafe(nil), spec = T.unsafe(nil)); end
  end
end

module Solargraph::YardMap::Mapper::ToMethod
  extend ::Solargraph::YardMap::Helpers

  class << self
    def make(code_object, name = T.unsafe(nil), scope = T.unsafe(nil), visibility = T.unsafe(nil), closure = T.unsafe(nil), spec = T.unsafe(nil)); end

    private

    # @param a [Array]
    # @return [String]
    def arg_name(a); end

    # @param a [Array]
    # @return [::Symbol]
    def arg_type(a); end

    # @param code_object [YARD::CodeObjects::Base]
    # @return [Array<Solargraph::Pin::Parameter>]
    def get_parameters(code_object, location, comments); end
  end
end

module Solargraph::YardMap::Mapper::ToNamespace
  extend ::Solargraph::YardMap::Helpers

  class << self
    def make(code_object, spec, closure = T.unsafe(nil)); end
  end
end

class Solargraph::YardMap::NoYardocError < ::StandardError; end

module Solargraph::YardMap::RdocToYard
  extend ::Solargraph::ApiMap::SourceToYard

  class << self
    def base_name(mod); end

    # @param cmnt [RDoc::Comment]
    # @return [String]
    def commentary(cmnt); end

    def find_file(obj); end

    # @param obj [RDoc::Context]
    def locate(obj); end

    # @param spec [Gem::Specification]
    # @param cache_dir [String]
    # @return [void]
    def run(spec, cache_dir: T.unsafe(nil)); end
  end
end

module Solargraph::YardMap::StdlibFills
  class << self
    # @param path [String]
    # @return [Array<Pin::Reference::Override>]
    def get(path); end
  end
end

Solargraph::YardMap::StdlibFills::LIBS = T.let(T.unsafe(nil), Hash)
Solargraph::YardMap::StdlibFills::Override = Solargraph::Pin::Reference::Override

class Solargraph::YardMap::ToMethod
  extend ::Solargraph::YardMap::Helpers

  def make(code_object, name = T.unsafe(nil), scope = T.unsafe(nil), visibility = T.unsafe(nil), closure = T.unsafe(nil), spec = T.unsafe(nil)); end
end

module Solargraph::YardMap::ToMethod::InnerMethods
  private

  # @param a [Array]
  # @return [String]
  def arg_name(a); end

  # @param a [Array]
  # @return [::Symbol]
  def arg_type(a); end

  # @param code_object [YARD::CodeObjects::Base]
  # @return [Array<Solargraph::Pin::Parameter>]
  def get_parameters(code_object, location, comments); end

  class << self
    # @param a [Array]
    # @return [String]
    def arg_name(a); end

    # @param a [Array]
    # @return [::Symbol]
    def arg_type(a); end

    # @param code_object [YARD::CodeObjects::Base]
    # @return [Array<Solargraph::Pin::Parameter>]
    def get_parameters(code_object, location, comments); end
  end
end
